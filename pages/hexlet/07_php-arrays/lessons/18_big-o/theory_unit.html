<!DOCTYPE html>
<html class='h-100' lang='ru' prefix='og: https://ogp.me/ns#'>

<head>
  <title>Big O - PHP: Массивы</title>
  <meta content='width=device-width, initial-scale=1.0' name='viewport'>
  <meta charset='utf-8'>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD" crossorigin="anonymous">
</head>

<body class='h-100'>
  <div class='d-flex flex-column flex-md-row h-100'>
    <div class='x-border-md-right flex-fill tab-content overflow-hidden h-100'>
      <div aria-labelledby='lesson-tab' class='tab-pane fade show active overflow-auto h-100' id='lesson'
        role='tabpanel'>
        <div class='container-xl my-3 mb-md-4 mb-lg-5'>
          <div class='row justify-content-center'>
            <div class='col-12 col-lg-10'>
            </div>

            <div class='mt-3 paywall'>
              <div class='p-2 p-md-4 shadow-sm bg-white'>
                <div class='hexlet-markdown-body overflow-hidden p-2 p-md-4'>
                  <h1 class='mt-0 mb-4'>Big O</h1>
                  <p>Когда заходит речь про алгоритмы, нельзя не упомянуть понятие «сложность алгоритма» и нотация
                    О-большое (Big O notation). Она не только полезна при прохождении собеседований, но и даёт понимание
                    того, как вообще оценивать эффективность кода (очень относительно).</p>

                  <p>Как вы помните, алгоритмов сортировок существует много, я бы сказал <a
                      href="https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8#%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8"
                      target="_blank" rel="nofollow">очень много</a>. Все они выполняют одну и ту же задачу, но при этом
                    отличаются друг от друга. В информатике алгоритмы сравниваются друг с другом (или классифицируются)
                    по их вычислительной (или алгоритмической) сложности. Сложность оценивается по количеству
                    выполняемых операций. Понятно, что конкретное количество операций зависит от входных данных,
                    например, если массив отсортирован, то количество операций будет минимальным (но они все равно
                    будут, потому что алгоритм должен убедиться в том, что массив отсортирован). Если не отсортирован,
                    то для каждого алгоритма можно подобрать такие входные данные, при которых он будет работать
                    максимально долго и не эффективно. Эти случаи называют соответственно верхней и нижней границей.</p>

                  <p>Нотация Big O как раз придумана для описания алгоритмической сложности. Она призвана показать, как
                    сильно увеличится количество операций при увеличении размера данных.</p>

                  <p>Вот некоторые примеры того, как записывается сложность: <code>O(1)</code>, <code>O(n)</code>,
                    <code>O(nlog(n))</code>.</p>

                  <p><img alt="Sorting Big O" class="lazyload px-2 px-md-3 px-lg-4 px-xl-5"
                      data-src="https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6Ijc3MDg1YjRiNzAwNWFkZDU1MmYyNGE5YzVhYWM1ZTY5LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=a212c1e8a06812c91bb13abfa0a1aab61a1fb7061684f896f4e04cb06d7f365e"
                      src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>

                  <p><code>O(1)</code> описывает так называемую константную сложность. Например, обращение к элементу
                    массива по индексу оценивается константой, другими словами оно не зависит от размера массива,
                    поэтому внутри O записывается единица, символизирующая константу. А вот функция, которая печатает на
                    экран все элементы переданного массива используя обычный перебор имеет сложность <code>O(n)</code>
                    (линейная сложность). То есть количество выполняемых операций будет равно количеству элементов
                    массива. Именно это количество символизирует символ <code>n</code> в скобках.</p>

                  <p>Ещё один простой пример — вложенные циклы. Вспомните как работает поиск пересечений в
                    неотсортированных массивах. Для каждого элемента из одного массива проверяется каждый элемент
                    другого массива (либо через цикл, либо с помощью функции <code>in_array</code>, чья сложность
                    <code>O(n)</code>, ведь в худшем случае она просматривает весь массив). Если принять, что размеры
                    обоих массивов одинаковы и равны <code>n</code>, то получается, что поиск пересечений имеет
                    квадратичную сложность или <code>O(n\^2)</code> (n в квадрате). Существуют как очень эффективные,
                    так и абсолютно не эффективные алгоритмы. Первые, как правило имеют логарифмическую сложность,
                    последние — степенную, такую, при которой <code>n</code> находится в степени. Скорость работы
                    подобных алгоритмов падает с катастрофической скоростью даже при небольшом количестве элементов.</p>

                  <p>Нередко более быстрые алгоритмы быстрее не потому, что они лучше, а потому что они потребляют
                    больше памяти или имеют возможность паралеллиться (и если это происходит, то работают крайне
                    эффективно). Как и всё в инженерной деятельности, эффективность — компромисс. Выигрывая в одном
                    месте, мы проиграем где-то в другом.</p>

                  <p><img alt="Big O" class="lazyload px-2 px-md-3 px-lg-4 px-xl-5"
                      data-src="https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImI1NjdkNmIzYjg1Y2IxMjhmZmM4OTRkOTQ1OTc3MTM1LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=aa60edef1f106b66778991a2cf36081454902f1bcfad96f01d745b6ccd6afcad"
                      src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>

                  <p>Big O, во многом, теоретическая оценка, на практике всё может быть по-другому. Реальное время
                    выполнения зависит от множества факторов среди которых, архитектура процессора, операционная
                    система, язык программирования, доступ к памяти (последовательный или произвольный) и многое другое.
                  </p>

                  <p>Вопрос эффективности кода довольно опасен. В силу того, что многие начинают учить программирование
                    именно с алгоритмов (особенно в университете), им начинает казаться, что эффективность — это
                    главное. Код должен быть быстрым.</p>

                  <p>Такое отношение к коду гораздо чаще приводит к проблемам, чем делает его лучше. Важно понимать, что
                    эффективность — враг понимаемости. Такой код всегда сложнее, больше подвержен ошибкам, труднее
                    модифицируется, дольше пишется. А главное, настоящая эффективность редко когда нужна сразу или
                    вообще нужна. Обычно тормозит не код, а, например, запросы к базе данных или сеть. Но даже если код
                    выполняется медленно, то вполне вероятно, что именно тот участок, который вы пытаетесь
                    оптимизировать, вызывается за все время жизни программы всего лишь один раз и ни на что не влияет,
                    потому что работает с небольшим объёмом памяти, а где-то в это время есть другой кусок, который
                    вызывается тысячи раз, и приводит к реальному замедлению.</p>

                  <blockquote>
                    <p>Программисты тратят огромное количество времени, размышляя и беспокоясь о некритичных местах
                      кода, и пытаются оптимизировать их, что исключительно негативно сказывается на последующей отладке
                      и поддержке. Мы должны вообще забыть об оптимизации в, скажем, 97% случаев. Поспешная оптимизация
                      является корнем всех зол. И, напротив, мы должны уделить все внимание оставшимся 3%. — Дональд
                      Кнут</p>
                  </blockquote>

                  <p>Перед тем, как пытаться что-то оптимизировать, обязательно прочитайте <a
                      href="http://optimization.guide/" target="_blank" rel="nofollow">небольшую онлайн-книжку</a>,
                    которая хорошо объясняет суть всех оптимизаций.</p>

                  <hr class='my-5'>
                  <h4 class='mb-4'>Дополнительные материалы</h4>
                  <ol>
                    <li class='lead'>
                      <a target="_blank" href="https://bigocheatsheet.com/">Big-O Cheat Sheet</a>
                    </li>
                  </ol>

</body>

</html>