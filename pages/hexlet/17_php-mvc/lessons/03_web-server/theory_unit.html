<!DOCTYPE html>
<html class='h-100' lang='ru' prefix='og: https://ogp.me/ns#'>

<head>
  <title>Веб-сервер - Веб-разработка на PHP</title>
  <meta content='width=device-width, initial-scale=1.0' name='viewport'>
  <meta charset='utf-8'>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD" crossorigin="anonymous">
</head>

<body class='h-100'>
  <div class='d-flex flex-column flex-md-row h-100'>
    <div class='x-border-md-right flex-fill tab-content overflow-hidden h-100'>
      <div aria-labelledby='lesson-tab' class='tab-pane fade show active overflow-auto h-100' id='lesson'
        role='tabpanel'>
        <div class='container-xl my-3 mb-md-4 mb-lg-5'>
          <div class='row justify-content-center'>
            <div class='col-12 col-lg-10'>
              <div class='mt-3 paywall'>
                <div class='p-2 p-md-4 shadow-sm bg-white'>
                  <div class='hexlet-markdown-body overflow-hidden p-2 p-md-4'>
                    <h1 class='mt-0 mb-4'>Веб-сервер</h1>
                    <h2 id="protsessy">Процессы</h2>
                    <p>Давайте теперь посмотрим, для чего нужен веб-сервер. Ответ на этот вопрос требует небольшой
                      подготовки.</p>

                    <p>Единицей исполнения в операционных системах является процесс. Это некоторая абстракция внутри ОС
                      (имеется в виду, что процесс невозможно представить визуально). Любая запущенная программа
                      представляет собой либо один процесс, либо набор процессов. Например, в браузерах одна вкладка,
                      как правило, — это один процесс. Особенность процессов в том, что они изолированы друг от друга.
                      Например, сбой в одном процессе не влечёт за собой остановку работы других. Такое свойство
                      процессов можно наблюдать в тех ситуациях, когда одна из вкладок браузера начинает тормозить и в
                      конце концов зависает (и её не всегда удаётся закрыть!). В это время можно без проблем продолжать
                      использовать другие вкладки.</p>

                    <p>Внутри себя процесс может делиться на потоки, но эта деталь не влияет на описываемую тему,
                      поэтому я её опускаю. Подробнее о менеджменте процессов можно прочитать в <a
                        href="https://ru.hexlet.io/pages/recommended-books" target="_blank">книгах</a> по операционным
                      системам.</p>

                    <p><img alt="Process List" class="lazyload px-2 px-md-3 px-lg-4 px-xl-5"
                        data-src="https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjJiNjY4ZmQ5NmU0M2E1YjdjYzRjN2FlZTQyMGM3MTc1LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=a31ce7b8cd8700813830947e875eae660e8921c8d1e9f7185546a990f8216eee"
                        src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>

                    <p><em>Посмотреть список процессов в Linux можно командой <code>ps aux</code> либо
                        <code>top</code></em></p>

                    <p>Понимание процессов тесно связано с сетевым взаимодействием. Взаимодействие между двумя
                      компьютерами в сети — всегда сводится к взаимодействию двух процессов. Другими словами, нельзя
                      взять и подключиться к компьютеру в целом — можно подключиться только к конкретному процессу
                      конкретной программы. Происходит это так: одна программа, которая хочет, чтобы к ней можно было
                      подключаться по сети, при запуске начинает <em>слушать</em> сетевой сокет. Такая программа
                      называется сервером. Другая программа к ней подключается. Такая программа называется клиентом. В
                      случае веба, сервер — это конкретный веб-сервер, например, nginx, а клиент — это браузер.</p>

                    <p>Здесь нужно сделать небольшую ремарку насчёт &quot;слушать сетевой сокет&quot;. Сетевое
                      взаимодействие между программами двух компьютеров осуществляется с помощью протокола TCP, поверх
                      которого уже работает HTTP. Для обращения к другому компьютеру нужно знать два параметра:
                      <strong>IP-адрес</strong> и <strong>порт</strong>. Так вот &quot;слушать сетевой сокет&quot;
                      означает занять определённый порт (на определённом сетевом интерфейсе) и дать возможность
                      обращаться к процессу через него. Именно по номеру порта операционная система понимает, к какому
                      процессу пытаются обратиться.</p>

                    <p>Браузер, благодаря DNS, получает IP-адрес компьютера, на котором расположен сайт указанного
                      домена (например, google.com). А вот откуда он знает порт, на котором висит веб-сервер в ожидании
                      входящих запросов? Ответ на этот вопрос очень простой: существует <strong>соглашение</strong>,
                      согласно которому веб-сервер, обслуживающий сайт по протоколу HTTP, слушает порт <code>80</code>,
                      а протокол HTTPS обслуживается на порту <code>443</code>. Но так бывает не всегда. Во время
                      локальной разработки обычно используются другие порты, например, <code>3000</code>, или
                      <code>4000</code>. Сам номер не принципиален, главное, что он доступен для веб-сервера, и вы
                      обращаетесь через браузер именно к нему. Порт указывается через двоеточие после названия сайта,
                      например <code>www.google.com:80</code>.</p>

                    <p><img alt="Client-Server" class="lazyload px-2 px-md-3 px-lg-4 px-xl-5"
                        data-src="https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjdhMTdlZmM0ZjU2NWE2NDk4MjY5N2ZlMTY4NjQzMjM5LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=69e7a81b1814b1930391fea16412603a1a743700009153349f27147a893f4c40"
                        src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>
                    <h2 id="veb-server">Веб-сервер</h2>
                    <p>Веб-сервер — специализированная программа для обслуживания сайтов. Один веб-сервер может
                      обрабатывать практически любое число сайтов (Virtual Hosts в HTTP). В общем случае он
                      <strong>перенаправляет входящие сетевые запросы на код сайтов, получает от них ответ и возвращает
                        его браузеру</strong>. Кроме главной функции, у веб-серверов огромное число вспомогательных.
                      Среди них кеширование, перезапись запросов, раздача статики (например, картинки), reverse proxy,
                      балансировка нагрузки и многое другое. Веб-сервера ничего не знают про то, на чём написан сайт.
                      Все способы взаимодействия веб-сервера и сайта на любом языке стандартизированы. Благодаря этому
                      веб-серверов существует не так много, и все они могут работать с сайтами, написанными на чём
                      угодно.</p>

                    <p>Первым и самым простым способом взаимодействия веб-сервера с сайтом был <strong>CGI</strong>
                      (Common Gateway Interface). Этот стандарт сразу разрабатывался с учётом того, что сервер не должен
                      зависеть от того, на чём написан сайт. Он основан на переменных окружения. По сути, сайт
                      представляет из себя исполняемый файл, который запускается веб-сервером во время обработки
                      входящего запроса и передаёт в него все параметры запроса через переменные окружения. Всё, что
                      требуется от скрипта, — это вернуть HTTP-ответ в стандартный вывод (STDOUT). Общий алгоритм работы
                      выглядит так:</p>

                    <ol>
                      <li> Клиент запрашивает страницу сайта.</li>
                      <li> Веб-сервер принимает запрос и устанавливает переменные окружения (через них приложению
                        передаются данные и служебная информация).</li>
                      <li> Веб-сервер перенаправляет запросы через стандартный поток ввода (stdin) на вход вызываемой
                        программы.</li>
                      <li> CGI-приложение выполняет все необходимые операции и формирует результаты в виде HTML.</li>
                      <li> Сформированный гипертекст возвращается веб-серверу через стандартный поток вывода (stdout).
                        Сообщения об ошибках передаются через поток ошибок (stderr).</li>
                      <li> Веб-сервер передаёт результаты запроса клиенту.</li>
                    </ol>

                    <p><img alt="CGI" class="lazyload px-2 px-md-3 px-lg-4 px-xl-5"
                        data-src="https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImIwYjA4OWNkMzY5MDkzZWQ1YzVjODI5N2NhMjUxNzMzLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=376cb571bcde8e330107a890510b8be2f30409bd6b4347e9d6f4480080089612"
                        src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>

                    <p>Очень важно осознать, что в режиме CGI, скрипт, который представляет из себя сайт (как
                      программу), запускается на каждый запрос заново. Это значит, что вся логика инициализации
                      отрабатывает для каждого запроса по новой, а после выполнения запроса, ничего не остаётся (скрипт
                      просто завершается). Если между запросами есть некоторое состояние (например, пользователь что-то
                      сохранил), то его нужно отправлять в какое-то хранилище, файловую систему (создать файл) или базу
                      данных.</p>
                    <h2 id="realizatsii">Реализации</h2>
                    <p>Разных веб-серверов довольно много. Начиная от встроенного в сам PHP, с которым мы познакомимся
                      очень скоро, заканчивая веб-серверами общего назначения, которые используются всеми. Самым
                      популярным и эффективным решением на текущий момент является nginx. Именно с ним и стоит
                      познакомиться. Для разработки он не понадобится, так как в PHP встроен свой сервер, но в
                      продакшен-среде без него никак. Кроме него набирает популярность веб-сервер Caddy, который хоть и
                      не такой быстрый, но обладает рядом важных особенностей, он значительно проще в настройке, из
                      коробки умеет генерировать сертификаты и многое другое.</p>

                    <p>Кроме указанных серверов, в PHP мире до сих пор пользуется популярностью Apache. Этот веб-сервер
                      когда-то был передовым решением, но те времена давно ушли. Использовать Apache можно только в том
                      случае, если у вас нет выбора, например, на хостинге предлагают именно его. Во всех остальных
                      ситуациях предпочтительнее nginx. Связано это с моделью работы самого сервера. Apache работает по
                      модели &quot;поток за запрос&quot;, что значительно более затратно и медленно по сравнению с
                      асинхронной моделью nginx.</p>
                    <h2 id="samostoyatelnaya-rabota">Самостоятельная работа</h2>
                    <p>Установите nginx и убедитесь в том, что он запускается и работает. Сделать это можно по одному из
                      руководств в сети, которые гуглятся так:
                      <code>php nginx &lt;имя вашей операционной системы&gt;</code>. Это задание повышенной сложности.
                      Если не получается прямо сейчас, то не тратьте время, сначала пройдите курс, а затем попробуйте
                      ещё раз.</p>

                    <hr class='my-5'>
                    <h4 class='mb-4'>Дополнительные материалы</h4>
                    <ol>
                      <li class='lead'>
                        <a target="_blank" href="https://ru.wikipedia.org/wiki/Сокет_(программный_интерфейс)">Сетевые
                          сокеты</a>
                      </li>
                      <li class='lead'>
                        <a target="_blank" href="https://ru.wikipedia.org/wiki/CGI">CGI</a>
                      </li>
                      <li class='lead'>
                        <a target="_blank" href="https://ru.wikipedia.org/wiki/FastCGI">FastCGI</a>
                      </li>
                    </ol>

</body>

</html>