<!DOCTYPE html>
<html class='h-100' lang='ru' prefix='og: https://ogp.me/ns#'>

<head>
  <title>Model-View-Controller (MVC) - Веб-разработка на PHP</title>
  <meta content='width=device-width, initial-scale=1.0' name='viewport'>
  <meta charset='utf-8'>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD" crossorigin="anonymous">
</head>

<body class='h-100'>
  <div class='d-flex flex-column flex-md-row h-100'>
    <div class='x-border-md-right flex-fill tab-content overflow-hidden h-100'>
      <div aria-labelledby='lesson-tab' class='tab-pane fade show active overflow-auto h-100' id='lesson'
        role='tabpanel'>
        <div class='container-xl my-3 mb-md-4 mb-lg-5'>
          <div class='row justify-content-center'>
            <div class='col-12 col-lg-10'>
              <div class='mt-3 paywall'>
                <div class='p-2 p-md-4 shadow-sm bg-white'>
                  <div class='hexlet-markdown-body overflow-hidden p-2 p-md-4'>
                    <h1 class='mt-0 mb-4'>Model-View-Controller (MVC)</h1>
                    <p>Архитектура веб-приложений в первую очередь определяется самой природой веба, тем, как работает
                      HTTP. Последовательность <strong>запрос-обработка-ответ</strong> — базис, на который нанизывается
                      все остальное. Фреймворки идут дальше и разделяют приложение на дополнительные слои уже внутри
                      самого процесса обработки запроса. Такое разделение напрашивается само собой, без него код быстро
                      превращается в мешанину из запросов к базе данных, формирований html и логики обработки данных.
                    </p>

                    <p>Из обработки запроса естественным образом выделяется слой шаблонов, на основе которых
                      генерируется HTML. Этот слой принято называть <em>View</em> (представление). Кроме него, как
                      минимум, выделяют ещё два слоя: <em>Model</em> (модель) и <em>Controller</em> (контроллер).
                      Остальное добавляется по мере роста сложности приложения. Аббревиатура <strong>MVC</strong>
                      (Model-View-Controller) — тема нашего урока.</p>

                    <p><em>Существует две разных версии MVC. Та, которая была придумана изначально (в сообществе
                        программистов на SmallTalk), создавалась под толстые клиенты, а они представляют собой
                        событийные системы, как современные фронтенд-приложения. На сервере используется другая вариация
                        MVC, которая называется MVC v2. Буквы в ней те же, но означают местами другое, и самое главное,
                        что совсем по-другому строится взаимодействие.</em></p>

                    <p><img alt="MVC" class="lazyload px-2 px-md-3 px-lg-4 px-xl-5"
                        data-src="https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjIxZmIxZTJmYWU4YWY3MzBmNjhkYjhlMDNhMzI3ZDNlLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=e2ec32b507379cf42f97c680348491f9eca9ee9eb166a4a2cc348db5a453364d"
                        src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>

                    <p>Архитектурный шаблон MVC задаёт основную структуру приложения и позволяет коду достаточно долго
                      развиваться, оставаясь удобным в поддержке. MVC, с некоторыми модификациями, реализуется всеми
                      веб-фреймворками. И если с представлением всё понятно, то с моделью и контроллером нужно
                      разбираться отдельно. Под контроллерами понимаются обработчики запросов. Они принимают объект
                      запроса и возвращают объект ответа. В случае Slim, контроллеры представлены анонимными функциями,
                      но это не обязательно: в больших фреймворках контроллер — это класс, а обработчики — его методы.
                      Эти методы обычно именуют <strong>действиями</strong> (actions). В принципе, на этом наше
                      разделение можно было бы и закончить. При таком подходе вся логика сосредоточена в самих
                      контроллерах, что вполне допустимо в самых примитивных случаях.</p>

                    <p>Во всех остальных ситуациях выделяют ещё один слой, который называют моделью. Сразу хочу
                      оговориться, что понятие «модель» не включает в себя <strong>персистентность</strong> (постоянное
                      хранение, базы данных). Среди разработчиков распространено заблуждение, что модель — это база
                      данных и данные внутри неё. Но это не так.</p>

                    <p>Слой модели отвечает за бизнес-логику приложения и данные, связанные с ней. Чисто технически,
                      этот слой может быть представлен большим количеством разных способов, которые ещё сильно зависят
                      от конкретного языка программирования и используемых библиотек. Самый распространённый вариант —
                      это ORM, но так бывает не всегда. Более того, довольно часто, даже при наличии отдельного слоя
                      модели, часть логики все же проникает в контроллеры.</p>

                    <p>Зачем понадобилось выделять слой модель? Достаточно давно мне попалась на глаза интересная
                      статья, которая называлась <a
                        href="http://blog.firsthand.ca/2011/10/rails-is-not-your-application.html" target="_blank"
                        rel="nofollow">Rails is not your application</a> (Rails — популярный веб-фреймворк, который стал
                      прообразом для большинства современных фреймворков на разных языках программирования). Идея статьи
                      заключается в том, что предметная область, которую мы реализуем внутри нашего сайта, никак не
                      связана ни с сайтом ни тем более с фреймворком, который используется внутри. Посудите сами, могут
                      ли поменяться правила бухгалтерии в зависимости от выбранного фреймворка и вообще, как связана
                      бухгалтерия и фреймворк? Очевидно, никак и бизнес-правила этой области не зависят от существования
                      программирования. Посредством программирования мы можем их выразить в коде, но этот код снова не
                      будет связан с используемым фреймворком. В идеале, код, который описывает предметную область и
                      позволяет с ней работать, можно взять и перенести в другой фреймворк без модификаций. Как видно,
                      на логическом уровне есть граница между кодом, моделирующим предметную область, и кодом,
                      обслуживающим веб-запросы. Но эту границу иногда провести трудно. Например, к чему относится
                      отправка письма при регистрации, а авторизация, а восстановление пароля? Если закапываться дальше,
                      то на горизонте возникают понятия Application Logic и Business Logic, а затем и Service Layer.
                      Если вам интересно, то прочитайте про них самостоятельно.</p>

                    <p>Самая большая сложность в коде находится именно в этой части приложения. Модель не имеет никакой
                      чёткой структуры, это не классическое запрос-обработка-ответ. Моделирование предметной области
                      довольно сложная тема, на почве которой родится ещё не мало холиваров.</p>

                    <p><img alt="MVC Relations" class="lazyload px-2 px-md-3 px-lg-4 px-xl-5"
                        data-src="https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjkzYTUyMDAwMTkyYzE1OWI4MjJkZGMwYTRmOTVjNzYwLmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=593a5634cdde4795771c8a2353ad26579f611a6ffd9c531fbbcc96bbf21afc4a"
                        src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /></p>

                    <p>Взаимоотношения между слоями в MVC не менее важны, чем наличие самих слоёв. Модель, как мы уже
                      выяснили, живёт своей жизнью и не знает (и не может знать) ничего про существование контроллера
                      или представления. Последние, в свою очередь, используют модель для запуска бизнес-логики или для
                      формирования HTTP-ответа. Контроллер инициирует различные процессы и запуск бизнес-логики. Кроме
                      того, контроллер отвечает за формирование ответа и запускает рендеринг шаблонов. Шаблоны не знают
                      про существование слоя контроллера, но используют данные, предоставленные им для формирования HTML
                      (или JSON, или чего-то ещё).</p>


</body>

</html>