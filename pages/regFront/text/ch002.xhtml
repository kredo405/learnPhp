<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="ru-RU">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch002.xhtml</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="первые-селекторы" class="level1" data-number="2">
<h1 data-number="2">2. Первые селекторы</h1>
<div class="text-container text-container--module">
<p>В этом разделе мы познакомимся с поиском одиночных символов, набором (диапазоном) символов их отрицанием, затронем тему экранирования.</p>
</div>
<section id="одиночный-символ" class="level2" data-number="2.1">
<h2 data-number="2.1">2.1. Одиночный символ</h2>
<div class="text-container text-container--module">
<p>Настало время перейти к изучению основ составления регулярных выражений. И первое, с чем мы познакомимся — одиночный символ.</p>
<p>Что это за символ? Абсолютно неважно: цифра, буква, пробельный, печатный или непечатный, всё это символы, каждый из которых в отдельности мы можем найти и обработать. Начнём с простого: заменим <code>м</code> на <code>п</code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="st">&#39;мама&#39;</span><span class="op">.</span><span class="fu">replace</span>(<span class="ss">/м/</span><span class="op">,</span> <span class="st">&#39;п&#39;</span>)<span class="op">;</span> <span class="co">// пама</span></span></code></pre></div>
<p>Не совсем то, что нужно, ведь мы ожидали, что будут заменены оба символа. Связано это с тем, что регулярное выражение по умолчанию <strong>всегда</strong> совпадает с первым найденным селектором.</p>
<p>Чтобы корректно решить задачу, забежим немного вперёд и познакомимся с модификатором <code>g</code>, который позволяет работать не только с первым, а со всеми совпадениями.</p>
<p>Модификаторы ставятся после закрывающего слэша основной части регулярного выражения: <code>/паттерн/g</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="st">&#39;мама&#39;</span><span class="op">.</span><span class="fu">replace</span>(<span class="ss">/м/g</span><span class="op">,</span> <span class="st">&#39;п&#39;</span>)<span class="op">;</span> <span class="co">// папа</span></span></code></pre></div>
<p>Теперь выглядит лучше. Задачу можно было решить и без регулярных выражений, но мы сейчас намеренно упрощаем.</p>
<p><strong>Решим реальную задачу</strong></p>
<p>Некоторые редакции требуют определенного стиля написания текста, который не приемлет букву <code>ё</code>. Давайте поможем редакции и поменяем её на <code>е</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> <span class="op">=</span> <span class="fu">str</span> <span class="vs">`Лёня и Алёша гуляли во дворе. Потом вышел Серёжа. С ним была сестрёнка Алёнка. Серёжа нёс санки. Дети стали катать Алёнку. Потом пришли Лёва и тётя Таня. Они купили ёлку. Лёва отнёс ёлку домой и стал катать ребят на санках. Лёва вёз на санках Лёню. Потом — Алёшу. Потом — Серёжу. Потом — Алёнку. Лёва — старший. Потом ребята все вместе катали Лёву. Весёлая была прогулка!`</span><span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>str<span class="op">.</span><span class="fu">replace</span>(<span class="ss">/ё/g</span><span class="op">,</span> <span class="st">&#39;е&#39;</span>)<span class="op">.</span><span class="fu">replace</span>(<span class="ss">/Ё/g</span><span class="op">,</span> <span class="st">&#39;Е&#39;</span>)<span class="op">;</span></span></code></pre></div>
<p>Мы вынуждены использовать подряд два <code>.replace()</code>, потому что ещё не умеем управлять сохранёнными состояниями. Но мы сможем вернуться к этому примеру в следующих разделах и упростить его.</p>
<hr />
<p>Мы только начали строить наши первые выражения, а уже научились выбирать и заменять одиночные символы.</p>
</div>
</section>
<section id="чувствительность-к-регистру" class="level2" data-number="2.2">
<h2 data-number="2.2">2.2. Чувствительность к регистру</h2>
<div class="text-container text-container--module">
<p>Регулярные выражения всегда выбирают точные совпадения, поэтому чувствительны к регистру — как ещё говорят, регистрозависимы.</p>
<p>Если по условию задачи мы не знаем, как будет написано слово, со строчной или прописной буквы, то стоит немного расширить правило, добавив оба возможных варианта. Обобщенное правило будет называться <strong>«последовательность символов»</strong>.</p>
<p>Объединять символы можно с помощью квадратных скобок, тогда наш пример будет выглядеть так:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="st">&#39;Мама&#39;</span><span class="op">.</span><span class="fu">replace</span>(<span class="ss">/</span><span class="sc">[Мм]</span><span class="ss">/g</span><span class="op">,</span> <span class="st">&#39;п&#39;</span>)<span class="op">;</span> <span class="co">// папа</span></span></code></pre></div>
<p>Здесь важно отметить, что хоть мы и написали два символа внутри селектора, совпадать они будут только с одной буквой. Также мы пока не умеем работать с сохраненными состояниями, поэтому получили результат, написанный в нижнем регистре.</p>
<p>Между тем мы уже сделали то, ради чего задумывались регулярные выражения: нашли «плавающие» данные и смогли их изменить.</p>
<p>Теперь здесь же опишем дополнительные варианты правил, которые совпадут со вторым символом <code>а</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="st">&#39;Мама&#39;</span><span class="op">.</span><span class="fu">replace</span>(<span class="ss">/</span><span class="sc">[Мм][Аа]</span><span class="ss">/g</span><span class="op">,</span> <span class="st">&#39;па&#39;</span>)<span class="op">;</span> <span class="co">// папа</span></span></code></pre></div>
<p>Почему не <code>[МмАа]</code>? Ещё раз уточним: одни скобки — один символ, одно совпадение. <code>[МмАа]</code> может совпасть с любой буквой слова <code>мама</code>, и результатом <code>'мама'.replace(/[МмАа]/g, 'па');</code> будет <code>папапапа</code>.</p>
<blockquote>
<p>Рекомендуем для понимания и усвоения материала проговаривать регулярное выражение словами.</p>
</blockquote>
<p>Например, объясним последнее <code>/[Мм][Аа]/g</code>: выражение совпадает с буквой <code>м</code> в любом регистре, следом за которой идет буква <code>а</code>, и все эти последовательности могут совпадать неограниченное количество раз.</p>
<p>Усложним исходную строку:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="st">&#39;Мама и Папа&#39;</span><span class="op">.</span><span class="fu">replace</span>(<span class="ss">/</span><span class="sc">[МмПп]</span><span class="ss">/g</span><span class="op">,</span> <span class="st">&#39;б&#39;</span>)<span class="op">;</span> <span class="co">// баба и баба</span></span></code></pre></div>
<p>Обратите внимание, внутри обобщающих скобок мы написали уже <strong>четыре</strong> символа, которые совпадают с двумя в разных регистрах, но всё ещё объектом поиска для данного селектора остается одна буква из перечисленных.</p>
<p><strong>Решим реальную задачу</strong></p>
<p>Заменим в тексте все <code>м2</code> и <code>м3</code> на <code>м²</code> и <code>м³</code> соответственно, и если они написаны в верхнем регистре, заменим и поставим их в нижнем, как и положено в единицах Си.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> str <span class="op">=</span> <span class="vs">`На лесопилку завезли 32 м3 леса, из которых 4 М3 пустили под распил на 25 мм доски длиной по 6 м.`</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>str<span class="op">.</span><span class="fu">replace</span>(<span class="ss">/</span><span class="sc">[мМ]</span><span class="ss">2/g</span><span class="op">,</span> <span class="st">&#39;м²&#39;</span>)<span class="op">.</span><span class="fu">replace</span>(<span class="ss">/</span><span class="sc">[мМ]</span><span class="ss">3/g</span><span class="op">,</span> <span class="st">&#39;м³&#39;</span>)<span class="op">;</span></span></code></pre></div>
<hr />
<p>Регистр в регулярных выражениях имеет важное значение. Но есть возможности, позволяющие комбинировать варианты символов и избегать чувствительности к регистру.</p>
</div>
</section>
<section id="наборы-символов" class="level2" data-number="2.3">
<h2 data-number="2.3">2.3. Наборы символов</h2>
<div class="text-container text-container--module">
<p>Назревает справедливый вопрос: а что делать, если нужно перечислить весь диапазон букв или какую-то их часть. Не перечислять же их все?</p>
<p>Для решения таких задач в символьном классе можно перечислять целые последовательности, указывая только начальные и конечные символы, например:</p>
<ul>
<li><strong>[0-9]</strong> — число от 0 до 9,</li>
<li><strong>[a-z]</strong> — латинские буквы в нижнем регистре,</li>
<li><strong>[а-яё]</strong> — русские буквы в нижнем регистре.</li>
</ul>
<blockquote>
<p>Важная особенность написания символьного класса русских букв для языка JavaScript: буква <code>ё</code> не входит в диапазон буквенных литералов. Аналогично с другими языками, содержащими умляуты (буквы с точками) — их придётся описывать отдельно.</p>
</blockquote>
<p>Как мы с вами уже разобрали выше, любой из буквенных классов можно сделать универсальным и представить в двух регистрах. Например, так: <code>[а-яА-ЯёЁ]</code>, что соответствует всему русскому алфавиту.</p>
<p>Символьные классы можно комбинировать. Например, если вы хотите в текстовой строке найти шестнадцатеричное значение цвета, то можете использовать:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ss">/#</span><span class="sc">[A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9]</span><span class="ss">/</span><span class="op">.</span><span class="fu">test</span>(<span class="st">&#39;Этот цвет #FF0000 — красный&#39;</span>) <span class="co">// true</span></span></code></pre></div>
<p>Для каждой последовательности символов мы описали отдельные квадратные скобки и отдельный символьный класс, заранее предусмотрев, что буквы могут быть написаны в разном регистре.</p>
<p>Стоит обратить внимание на первый символ <code>#</code>, который можно назвать якорным. Пока этот символ не совпадёт в тексте, другие селекторы не будут проверяться и не будет происходить возврат.</p>
<blockquote>
<p>Сейчас наше правило с цветом неоптимальное, его можно значительно сократить. Мы сделаем это в следующих главах.</p>
</blockquote>
<p>Если вы заметили, мы использовали только часть диапазона латинских букв до буквы <code>F</code>, потому что остальные в шестнадцатеричном коде не используются. Также нет никакой разницы, какие символы ставить вперед, а какие — назад, цифры и буквы можно указывать в любом порядке. Однако даже для этой задачи лучше переставить местами цифры и буквы, так как вероятность выпадения цифр выше.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ss">/#</span><span class="sc">[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]</span><span class="ss">/</span><span class="op">.</span><span class="fu">test</span>(<span class="st">&#39;Этот цвет #FF0000 — красный&#39;</span>) <span class="co">// true</span></span></code></pre></div>
<p>Если вы не используете нижний регистр букв для обозначения цвета, то можно сократить правило. Оно станет более точным и будет давать на <code>23 * 6</code> меньше возвратов.</p>
<p><strong>Решим реальную задачу</strong></p>
<p>Напишем атрибут <code>pattern</code> для валидации элемента формы, чтобы можно было вводить год рождения</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;input</span> <span class="er">type</span><span class="ot">=</span><span class="st">&quot;number&quot;</span> <span class="er">name</span><span class="ot">=</span><span class="st">&quot;year&quot;</span> <span class="er">min</span><span class="ot">=</span><span class="st">&quot;1900&quot;</span> <span class="er">placeholder</span><span class="ot">=</span><span class="st">&quot;1979&quot;</span> <span class="er">pattern</span><span class="ot">=</span><span class="st">&quot;[12][0-9][0-9][0-9]&quot;</span><span class="kw">&gt;</span></span></code></pre></div>
<hr />
<p>Подытожим, в символьный класс, внутри квадратных скобок <code>[]</code>, мы можем писать любые одиночные символы или их последовательности, которые совпадают с одним символом в исходной строке.</p>
</div>
</section>
<section id="экранирование-символов" class="level2" data-number="2.4">
<h2 data-number="2.4">2.4. Экранирование символов</h2>
<div class="text-container text-container--module">
<p>После предыдущей части у вас мог появиться закономерный вопрос. А что делать, если внутри квадратных скобок нужно поставить сами символы квадратных скобок или дефис, который используется в качестве служебного символа диапазона?</p>
<p>Тут всё предельно просто. Чтобы символ потерял своё функциональное значение, его нужно экранировать или поставить перед ним символ обратного слэша <code>\</code>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ss">/</span><span class="sc">[\[\]]</span><span class="ss">/</span><span class="op">.</span><span class="fu">test</span>(<span class="st">&#39;Эта строка содержит [квадратные] скобки&#39;</span>) <span class="co">// true</span></span></code></pre></div>
<p><strong>А как экранируют сам символ обратного слэша?</strong></p>
<p>Здесь стоит сделать лирическое отступление. Символ обратного слэша <code>\</code> является служебным символом языка JavaScript. Он экранирует служебные символы в тексте, такие как символ новой строки <code>\n</code>. Поэтому обратный слэш и в тексте, и в регулярном выражении должен быть экранирован следующим образом:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ss">/</span><span class="sc">\\</span><span class="ss">/</span><span class="op">.</span><span class="fu">test</span>(<span class="st">&#39;left</span><span class="sc">\\</span><span class="st">right&#39;</span>) <span class="co">// true</span></span></code></pre></div>
<p>Осталось разобрать, что делать с символом дефиса <code>-</code>, ведь он может быть использован и как часть строки, и как часть символьного класса. Давайте рассмотрим примеры:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="st">&#39;2021-09-25&#39;</span><span class="op">.</span><span class="fu">split</span>(<span class="ss">/-/</span>) <span class="co">// [&#39;2021&#39;, &#39;09&#39;, &#39;25&#39;]</span></span></code></pre></div>
<p>Как отдельный символ (не в составе символьного класса) дефис экранировать не нужно, он является обычным литералом.</p>
<p>Если использовать дефис внутри символьного класса, то его лучше ставить на первое место. Тогда он точно будет рассматриваться как отдельный символ, а не диапазон:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ss">/</span><span class="sc">[-a-zA-Z0-9_]+</span><span class="ss">/</span><span class="op">.</span><span class="fu">test</span>(<span class="st">&#39;container-left_block&#39;</span>) <span class="co">// true</span></span></code></pre></div>
<p>Как всегда мы немного забегаем вперёд, метасимвол <code>+</code> используется для повторения <strong>один или более</strong> раз символьного селектора. В итоге выражение совпадёт со всей строкой.</p>
<p><strong>Решим реальную задачу</strong></p>
<p>Заменим в тексте любые совпадения <code>(с)</code> на символ <code>©</code>.Причём мы не знаем, в каком регистре эти символы встречаются в тексте, и не знаем, написаны они латиницей или кириллицей.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> str <span class="op">=</span> <span class="vs">`(C) — знак охраны авторского права, представляет собой латинскую букву C (первая буква слова «copyright») в окружности. Знак охраны авторского права (с) используется с именем физического или юридического лица, которому принадлежат авторские права.`</span><span class="op">;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>str<span class="op">.</span><span class="fu">replace</span>(<span class="ss">/</span><span class="sc">\([cCсС]\)</span><span class="ss">/g</span><span class="op">,</span> <span class="st">&#39;©&#39;</span>)</span></code></pre></div>
<p>Решая эту задачу, мы просто перечислили все возможные варианты написания <code>сС</code>, а круглые скобки экранировали.</p>
<hr />
<p>Подытожим. Служебные символы тоже могут участвовать и быть частью регулярных выражений. Не нужно этого бояться, всё решается с помощью <code>\</code>.</p>
</div>
</section>
<section id="отрицание" class="level2" data-number="2.5">
<h2 data-number="2.5">2.5. Отрицание</h2>
<div class="text-container text-container--module">
<p>Задачи бывают очень разнообразными, и не всегда символы должны совпадать — иногда нужно, чтобы они не совпали.</p>
<p>Так, например, мы уже сейчас можем написать небольшое правило валидации идентификаторов тегов.</p>
<blockquote>
<p>Выдержка из спецификации HTML4: ID и NAME должны начинаться с латинских букв <code>[A-Za-z]</code> в любом количестве и следующих за ними цифр <code>[0-9]</code>, дефисов, символа подчеркивания, двоеточия и точки <code>[-_:.]</code>.</p>
</blockquote>
<p>Другими словами, ID не может начинаться с цифры, символа подчеркивания или символов пунктуации. Чтобы решить задачу, нам не обойтись без отрицания.</p>
<blockquote>
<p>Обращаем внимание, что в спецификации HTML5 ограничение на символы было снято, но для обратной совместимости всё ещё рекомендуется использовать именование HTML4.</p>
</blockquote>
<p>Символ отрицания внутри селекторного класса — это символ карет <code>^</code>, который записывается перед остальными символами <code>[^]</code>. Если мы проговариваем этот селектор, то говорим: не совпадает с…</p>
<p>Давайте напишем небольшой пример, проверяющий наши ID.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> elements <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelectorAll</span>(<span class="st">&#39;*&#39;</span>)<span class="op">;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>elements<span class="op">.</span><span class="fu">forEach</span>((element) <span class="kw">=&gt;</span> {</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (element<span class="op">.</span><span class="at">id</span> <span class="op">!==</span> <span class="st">&#39;&#39;</span> <span class="op">&amp;&amp;</span> <span class="ss">/</span><span class="sc">^[^a-zA-Z]</span><span class="ss">/</span><span class="op">.</span><span class="fu">test</span>(element<span class="op">.</span><span class="at">id</span>)) {</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">alert</span>(<span class="vs">`Elements id=&quot;</span><span class="sc">${</span>element<span class="op">.</span><span class="at">id</span><span class="sc">}</span><span class="vs">&quot; is wrong!`</span>)<span class="op">;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span></code></pre></div>
<p>Наблюдательный студент заметит, что мы использовали символ карет <code>^</code> дважды. Один раз внутри символьного класса, чтобы обозначить отрицание, а второй раз как самостоятельный символ, но об этом далее.</p>
<hr />
<p>Необязательно, чтобы правило искало точное совпадение, можно найти и то, чего быть не должно. В этом и фокус!</p>
</div>
</section>
<section id="границы-текста" class="level2" data-number="2.6">
<h2 data-number="2.6">2.6. Границы текста</h2>
<div class="text-container text-container--module">
<p>Напоследок стоит рассказать о двух метасимволах, которые могут упростить построение регулярного выражения и сократить количество возвратов:</p>
<ul>
<li><strong>^</strong> — символ начала текста,</li>
<li><strong>$</strong> — символ конца текста.</li>
</ul>
<p>Важно уточнить, что для многострочных текстов эти метасимволы будут обозначать именно начало и конец всего текста, а не его отдельных строк.</p>
<p>Сразу несколько примеров:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ss">/</span><span class="sc">^</span><span class="ss">2021/</span><span class="op">.</span><span class="fu">test</span>(<span class="st">&#39;2020 год был менее богат на киношные события в сравнении с 2021-м&#39;</span>) <span class="co">// false</span></span></code></pre></div>
<p>Здесь символ начала текста <code>^</code> является якорем, без которого дальнейшая проверка селекторов невозможна. Поэтому, даже несмотря на то, что в тексте присутствует 2021, результатом будет <code>false</code>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="st">&#39;Работа была сдана 25.09.2020&#39;</span><span class="op">.</span><span class="fu">replace</span>(<span class="ss">/</span><span class="sc">[0-9]$</span><span class="ss">/</span><span class="op">,</span> <span class="st">&#39;1&#39;</span>) <span class="co">// Работа была сдана 25.09.2021</span></span></code></pre></div>
<p>В этом примере мы наоборот привязались к концу текста, хотя совпадений с символьным селектором <code>[0-9]</code> предостаточно.</p>
<p><strong>Решим реальную задачу</strong></p>
<p>У нас есть массив с номерами мобильных телефонов клиентов, и нам нужно передать их в API оператора для рассылки СМС-сообщений. Но некоторые номера написаны с неправильным кодом страны, <code>8</code> вместо <code>7</code>, и сообщения по этим номерам не отправятся. Нужно исправить эту неточность.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> data <span class="op">=</span> [<span class="st">&#39;85558345434&#39;</span><span class="op">,</span> <span class="st">&#39;71236452378&#39;</span><span class="op">,</span> <span class="st">&#39;75558755555&#39;</span><span class="op">,</span> <span class="st">&#39;83889068345&#39;</span><span class="op">,</span> <span class="st">&#39;80237862453&#39;</span>]</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> result <span class="op">=</span> data<span class="op">.</span><span class="fu">map</span>(item <span class="kw">=&gt;</span> item<span class="op">.</span><span class="fu">replace</span>(<span class="ss">/</span><span class="sc">^</span><span class="ss">8/</span><span class="op">,</span> <span class="st">&#39;7&#39;</span>))</span></code></pre></div>
<p>В этом примере важно наличие знака начала строки <code>^</code>, ведь без него будет заменён первый символ <code>8</code> в любом из номеров телефонов, даже в правильных.</p>
<hr />
<p>Подытожим. В регулярных выражениях языка JavaScript многострочный текст считается единой строкой. У текста есть границы, и пусть они невидимы, мы можем их обозначить и построить выражение от них.</p>
</div>
</section>
<section id="рисуем-смайлы" class="level2" data-number="2.7">
<h2 data-number="2.7">2.7. Рисуем смайлы</h2>
<div class="text-container text-container--module">
<p>Нам с сервера приходит небольшой массив с комментариями пользователей, в которых они добавляют длинные смайлы и тем самым растягивают нашу вёрстку. Давайте исправим ситуацию и вместо :) или :))))))))))))))))) поставим смайлик.</p>
<blockquote>
<p>Для решения вам понадобится квантификатор <code>+</code>, он задаёт повторения любого селектора. Также после выражения стоит поставить модификатор <code>/выражение/g</code>, чтобы правило срабатывало несколько раз.</p>
</blockquote>
<div class="sourceCode" id="cb20"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> comments <span class="op">=</span> [</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">name</span><span class="op">:</span> <span class="vs">`Вера`</span><span class="op">,</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">comment</span><span class="op">:</span> <span class="vs">`Фильм укатайка :)))))))))))))))))))`</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  }<span class="op">,</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">name</span><span class="op">:</span> <span class="vs">`Даниил`</span><span class="op">,</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">comment</span><span class="op">:</span> <span class="vs">`Были смешные моменты :), но в целом такое...`</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>  }<span class="op">,</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">name</span><span class="op">:</span> <span class="vs">`DarkLord`</span><span class="op">,</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">comment</span><span class="op">:</span> <span class="vs">`:)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))`</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>]<span class="op">;</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>comments<span class="op">.</span><span class="fu">forEach</span>((item<span class="op">,</span> i) <span class="kw">=&gt;</span> {</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ваше решение</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(comments)<span class="op">;</span></span></code></pre></div>
</div>
</section>
<section id="рисуем-смайлы-решение" class="level2" data-number="2.8">
<h2 data-number="2.8">2.8. Рисуем смайлы (решение)</h2>
<div class="text-container text-container--module">
<div class="sourceCode" id="cb21"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> comments <span class="op">=</span> [</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">name</span><span class="op">:</span> <span class="vs">`Вера`</span><span class="op">,</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">comment</span><span class="op">:</span> <span class="vs">`Фильм укатайка :)))))))))))))))))))`</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  }<span class="op">,</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">name</span><span class="op">:</span> <span class="vs">`Даниил`</span><span class="op">,</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">comment</span><span class="op">:</span> <span class="vs">`Были смешные моменты :), но в целом такое...`</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>  }<span class="op">,</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">name</span><span class="op">:</span> <span class="vs">`DarkLord`</span><span class="op">,</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">comment</span><span class="op">:</span> <span class="vs">`:)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))`</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>]<span class="op">;</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>comments<span class="op">.</span><span class="fu">forEach</span>((item<span class="op">,</span> i) <span class="kw">=&gt;</span> {</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>  item<span class="op">.</span><span class="at">comment</span> <span class="op">=</span> item<span class="op">.</span><span class="at">comment</span><span class="op">.</span><span class="fu">replace</span>(<span class="ss">/:</span><span class="sc">\)+</span><span class="ss">/g</span><span class="op">,</span> <span class="st">&#39;😀&#39;</span>)<span class="op">;</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(comments)<span class="op">;</span></span></code></pre></div>
<p>Выражение <code>/:\)+/</code> захватит первый селектор <code>:</code> и следующие за ним последовательности из одной или нескольких скобок <code>\)+</code>.</p>
<p>Подумайте, как улучшить пример и вместо одного смайла добавлять сразу три, если скобок больше 10.</p>
</div>
</section>
</section>
</body>
</html>
