<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="ru-RU">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch007.xhtml</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="хозяйке-на-заметку" class="level1" data-number="7">
<h1 data-number="7">7. Хозяйке на заметку</h1>
<div class="text-container text-container--module">
<p>Поговорим о том, что не вошло в основную часть курса.</p>
</div>
<section id="что-не-вошло" class="level2" data-number="7.1">
<h2 data-number="7.1">7.1. Что не вошло?</h2>
<div class="text-container text-container--module">
<p>Первое, о чём хочется рассказать — о механизме создания регулярных выражений в языке JavaScript. Может показаться странным, что мы говорим об этом сейчас, а не в начале курса. Но на самом деле отсутствие этих знаний не повлияло на общую картину восприятия.</p>
<p>Есть два способа создания регулярных выражений:</p>
<p><strong>Литеральный</strong></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> regex <span class="op">=</span> <span class="ss">/выражение/модификатор</span><span class="op">;</span></span></code></pre></div>
<p>Литеральный способ создаёт регулярное выражение без кавычек, элементы регулярного выражения не экранируются как строки JavaScript.</p>
<p>Регулярное выражение компилируется сразу на этапе объявления, поэтому удобнее его использовать там, где выражение не изменяется по ходу работы скрипта.</p>
<p><strong>С помощью конструктора</strong></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> regex <span class="op">=</span> <span class="kw">new</span> <span class="bu">RegExp</span>(<span class="st">&#39;выражение&#39;</span><span class="op">,</span> <span class="st">&#39;модификатор&#39;</span>)<span class="op">;</span></span></code></pre></div>
<p>Способ объявления через конструктор записывается как обычная строка, а потому нужно дополнительно экранировать специальные символы по правилам JavaScript-строк.</p>
<p>В отличие от литерального способа, конструктор компилирует правило перед выполнением, поэтому правила могут собираться динамически, в том числе и с помощью скрипта.</p>
<p><strong>Метод <code>.exec()</code></strong></p>
<p>Мы не затрагивали этот метод на курсе, потому что он более сложен для понимания. Если нам нужно просто поймать все совпадения, то можно воспользоваться <code>.match()</code>.</p>
<p>Метод <code>.exec()</code> возвращает массив и обновляет свойства объекта регулярного выражения.</p>
<p>Первый элемент возвращаемого массива содержит сопоставленный текст, а последующие — текст, который был захвачен при сопоставлении круглыми скобками.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> regex <span class="op">=</span> <span class="ss">/сколько нам </span><span class="sc">(</span><span class="ss">открытий</span><span class="sc">)</span><span class="ss">.</span><span class="sc">+?(</span><span class="ss">чудных</span><span class="sc">)</span><span class="ss">/ig</span><span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> parts <span class="op">=</span> regex<span class="op">.</span><span class="fu">exec</span>(<span class="vs">`О сколько нам открытий чудных</span><span class="sc">\n</span><span class="vs">Готовят просвещенья дух`</span>)<span class="op">;</span></span></code></pre></div>
<p>На выходе мы получим массив, где:</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 40%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr class="header">
<th>Индекс</th>
<th>Описание</th>
<th>Часть строки</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>0</strong></td>
<td>Сопоставление со строкой или её частью</td>
<td>О сколько нам открытий чудных</td>
</tr>
<tr class="even">
<td><strong>1…n</strong></td>
<td>Сопоставление с круглыми скобками</td>
<td>открытий, чудных</td>
</tr>
<tr class="odd">
<td><strong>parts.index</strong></td>
<td>Индекс сопоставления в строке, начинается с нуля</td>
<td>2</td>
</tr>
<tr class="even">
<td><strong>parts.input</strong></td>
<td>Оригинальная строка</td>
<td>О сколько нам открытий чудных\nГотовят просвещенья дух</td>
</tr>
</tbody>
</table>
<p>Помимо того, что у массива появляются свои свойства и значения, у регулярного выражения они тоже появляются.</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 60%" />
<col style="width: 24%" />
</colgroup>
<thead>
<tr class="header">
<th>Свойство</th>
<th>Описание</th>
<th>Значение</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>regex.lastIndex</strong></td>
<td>Индекс, с которого начинается следующее сопоставление. Если отсутствует <code>g</code>, равно нулю</td>
<td>29</td>
</tr>
<tr class="even">
<td><strong>regex.ignoreCase</strong></td>
<td>Квантификатор <code>i</code></td>
<td>true</td>
</tr>
<tr class="odd">
<td><strong>regex.global</strong></td>
<td>Квантификатор <code>g</code></td>
<td>true</td>
</tr>
<tr class="even">
<td><strong>regex.multiline</strong></td>
<td>Квантификатор <code>m</code></td>
<td>false</td>
</tr>
<tr class="odd">
<td><strong>regex.source</strong></td>
<td>Шаблон регулярного выражения</td>
<td>сколько нам (открытий).+? (чудных)</td>
</tr>
</tbody>
</table>
<p>Где применять <code>.exec()</code>? Там, где нужен детальный поиск совпадений и контроль за последней позицией совпадения.</p>
<p>Вспомним задачу про уровень игры, мы разбивали строку по буквам <code>AAAAAbbbbbbDbbb</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> regex <span class="op">=</span> <span class="ss">/</span><span class="sc">([a-zA-Z])\1{0,}</span><span class="ss">/gi</span><span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> str <span class="op">=</span> <span class="vs">`AAAAAbbbbbbDbbb`</span><span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> arr <span class="op">=</span> []<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> ((arr <span class="op">=</span> regex<span class="op">.</span><span class="fu">exec</span>(str)) <span class="op">!==</span> <span class="kw">null</span>) {</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="vs">`Найдено </span><span class="sc">${</span>arr[<span class="dv">0</span>]<span class="sc">}</span><span class="vs">. Следующее сопоставление начинается с позиции </span><span class="sc">${</span>regex<span class="op">.</span><span class="at">lastIndex</span><span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Найдено AAAAA. Следующее сопоставление начинается с позиции 5</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co">// Найдено bbbbbb. Следующее сопоставление начинается с позиции 11</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co">// Найдено D. Следующее сопоставление начинается с позиции 12</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="co">// Найдено bbb. Следующее сопоставление начинается с позиции 15</span></span></code></pre></div>
<p><strong>Редко используемые селекторы и модификаторы</strong></p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 82%" />
</colgroup>
<thead>
<tr class="header">
<th>Селектор</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong><code>\f</code></strong></td>
<td>Символ прогона страницы. Особый символ управления печатью</td>
</tr>
<tr class="even">
<td><strong><code>[\b]</code></strong></td>
<td>Соответствует бэкспейсу (U+0008)</td>
</tr>
<tr class="odd">
<td><strong><code>\0</code></strong></td>
<td>Соответствует символу NULL (U+0000)</td>
</tr>
<tr class="even">
<td><strong><code>\xhh</code></strong></td>
<td>Соответствует символам кода hh (две шестнадцатеричные цифры)</td>
</tr>
<tr class="odd">
<td><strong><code>\uhhhh</code></strong></td>
<td>Соответствует символам кода hhhh (четыре шестнадцатеричные цифры)</td>
</tr>
</tbody>
</table>
<p>Какие-то из этих селекторов, вроде <code>\uhhhh</code>, вы можете использовать редко для поиска специальных символов, а какие-то, вроде <code>[\b]</code>, не попадутся вам никогда.</p>
<p><code>U+0008</code> — управляющий символ, перемещающий каретку на один шаг назад. Он есть лишь потому, что его можно вставить из кода, а следовательно, должна быть возможность его найти.</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>Модификатор</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong><code>y</code></strong></td>
<td>Выполняет поиск, начиная с символа, находящегося на позиции свойства lastindex текущего регулярного выражения</td>
</tr>
</tbody>
</table>
<p>Проще всего понять это на примере:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> str <span class="op">=</span> <span class="vs">`авто мото вело фото`</span><span class="op">;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> regex <span class="op">=</span> <span class="ss">/.</span><span class="sc">+?(</span><span class="ss">то</span><span class="sc">)</span><span class="ss">/y</span><span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> parts <span class="op">=</span> regex<span class="op">.</span><span class="fu">exec</span>(str)<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(regex<span class="op">.</span><span class="at">lastIndex</span>)<span class="op">;</span> <span class="co">// 4</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(parts)<span class="op">;</span>           <span class="co">// авто</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> parts1 <span class="op">=</span> regex<span class="op">.</span><span class="fu">exec</span>(str)<span class="op">;</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(regex<span class="op">.</span><span class="at">lastIndex</span>)<span class="op">;</span> <span class="co">// 9</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(parts1)<span class="op">;</span>          <span class="co">// мото</span></span></code></pre></div>
<p>Первым совпадением в строке будет <strong>авто</strong>, <code>.exec()</code> изменит <code>lastIndex</code> на значение <code>4</code> и при следующем поиске совпадения начнёт с позиции <code>lastIndex</code>.</p>
<p>Модификатор <code>y</code> называют <strong>sticky</strong> — липким, потому что он прилипает к последней позиции совпадения в тексте.</p>
<p><strong>Паттерн важнее атрибутов</strong></p>
<p>Здесь больше не о регулярном выражении, а о поведении браузера при взаимодействии с <code>pattern</code>, потому что он имеет больший приоритет над атрибутами.</p>
<p>Сразу пример:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;input</span> <span class="er">type</span><span class="ot">=</span><span class="st">&quot;text&quot;</span> <span class="er">maxlength</span><span class="ot">=</span><span class="st">&quot;10&quot;</span> <span class="er">pattern</span><span class="ot">=</span><span class="st">&quot;\d{3}|\w{8}&quot;</span><span class="kw">&gt;</span></span></code></pre></div>
<p>Здесь <code>maxlength</code> никогда не сработает, потому что паттерн предполагает три цифры или восемь букв. Вы всё ещё можете записать <code>10</code> символов, но поле останется невалидным.</p>
<p><strong>Теги и регулярные выражения</strong></p>
<p>Среди программистов есть заблуждение, что работать с тегами посредством регулярных выражений — плохая практика. В этом есть доля правды, но давайте разберёмся.</p>
<p>Если ваша задача предполагает поиск элементов в DOM-дереве, то в языке JavaScript есть достаточно инструментов, чтобы это сделать и без регулярных выражений. К тому же вы получите доступ к DOM даже в том случае, если HTML написан не совсем корректно.</p>
<p>Браузер умеет прощать некоторые ошибки и достраивает элементы самостоятельно. Вспомните, например, о необязательности закрытия абзацного тега <code>&lt;p&gt;</code>.</p>
<blockquote>
<p>Абзацы являются блочными элементами и автоматически закрываются, если другой блочный элемент находится перед закрывающим тегом <code>&lt;/p&gt;</code></p>
</blockquote>
<p>При поиске тегов регулярными выражениями вы наверняка столкнётесь с проблемами контролирования кавычек атрибутов, их парности и присутствия этих же кавычек внутри содержимого тега. Это превратит задачу в очень сложную, и нужно адекватно оценивать необходимость такого подхода в решении.</p>
<p>Другое дело, если задача предполагает работать со строкой, содержащей теги. Или, как мы неоднократно делали в процессе курса, нужно добавить семантические или абзацные теги. Здесь регулярные выражения могут прекрасно справиться с задачей.</p>
<hr />
<p>Это один из самых сложных разделов. Не беда, если вы что-то поняли не сразу. Понимание часто приходит во время практики. Пишите больше регулярных выражений, и успех придет!</p>
</div>
</section>
<section id="точность-регулярных-выражений" class="level2" data-number="7.2">
<h2 data-number="7.2">7.2. Точность регулярных выражений</h2>
<div class="text-container text-container--module">
<p>Мы уже разобрались с тем, что в регулярных выражениях, как и в любом языке программирования, можно решать задачу разными способами. Мы даже вместе попробовали оптимизировать несколько примеров. Однако существуют такие текстовые конструкции, для которых нельзя однозначно составить правило, например, теги или электронная почта.</p>
<blockquote>
<p>Стоит ли проводить оптимизацию выражения, чтобы оно совпадало точно? И насколько точно?</p>
</blockquote>
<p>Это сложный вопрос, который каждый для себя должен решить сам. С одной стороны, на кону будут скорость и расход памяти, с другой, точность.</p>
<p>Разберём на примере адреса электронной почты: какова может быть цена точности.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> checkEmail <span class="op">=</span> (email) <span class="kw">=&gt;</span> <span class="ss">/</span><span class="sc">^[a-z0-9_.-]+</span><span class="ss">@</span><span class="sc">[a-z0-9-]+\.[a-z0-9-.]+$</span><span class="ss">/i</span><span class="op">.</span><span class="fu">test</span>(email)<span class="op">;</span></span></code></pre></div>
<p>Давайте проговорим правило:</p>
<ul>
<li><code>^[a-z0-9_.-]+</code> — это имя, где от начала строки встречаются латинские буквы, цифры и некоторые знаки;</li>
<li>затем символ <code>@</code> или в простонародье «собака»;</li>
<li>дальше идёт доменная часть, которая разбита на доменное имя <code>[a-z0-9-]+</code> и доменную зону <code>[a-z0-9-.]+</code>.</li>
</ul>
<p>С одной стороны, это необходимый минимум для валидации. Но всегда найдутся перфекционисты, которые скажут, что правило не покрывает абсолютно все варианты адресов по стандарту RFC.</p>
<p>Вот пример корректного адреса электронной почты <code>!#$%&amp;'*+-/=?^_{}|~@example.com</code></p>
<p>Готовы ли вы в своих проектах поддерживать подобное — решать вам. Стоит лишь помнить, что любое усложнение правил создаёт дополнительные варианты возвратов, и, как следствие, потерю в скорости работы скрипта и излишний расход памяти.</p>
<p>Неплохой обзор проблемы можно прочитать в статье «<a href="https://habr.com/ru/post/224623/">Никогда не проверяйте e-mail адреса по стандартам RFC</a>».</p>
<p>Мы же, со своей стороны, обязаны показать вам, как проверить адрес по стандарту <a href="https://www.ietf.org/rfc/rfc5322.txt">RFC 5322</a>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> checkEmail <span class="op">=</span> (email) <span class="kw">=&gt;</span> <span class="ss">/</span><span class="sc">(?</span><span class="ss">:</span><span class="sc">[a-z0-9!#$%&amp;&#39;*+/=?^_`{|}~-]+(?</span><span class="ss">:</span><span class="sc">\.[a-z0-9!#$%&amp;&#39;*+/=?^_`{|}~-]+)*|</span><span class="ss">&quot;</span><span class="sc">(?</span><span class="ss">:</span><span class="sc">[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*</span><span class="ss">&quot;</span><span class="sc">)</span><span class="ss">@</span><span class="sc">(?</span><span class="ss">:</span><span class="sc">(?</span><span class="ss">:</span><span class="sc">[a-z0-9](?</span><span class="ss">:</span><span class="sc">[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?</span><span class="ss">:</span><span class="sc">[a-z0-9-]*[a-z0-9])?|\[(?</span><span class="ss">:</span><span class="sc">(?</span><span class="ss">:25</span><span class="sc">[0-5]|</span><span class="ss">2</span><span class="sc">[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?</span><span class="ss">:25</span><span class="sc">[0-5]|</span><span class="ss">2</span><span class="sc">[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]</span><span class="ss">:</span><span class="sc">(?</span><span class="ss">:</span><span class="sc">[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])</span><span class="ss">/i</span><span class="op">.</span><span class="fu">test</span>(email)<span class="op">;</span></span></code></pre></div>
<p>Так выглядит боль. Попробуйте проговорить правило самостоятельно 🤪</p>
<p>Кроме боли должно быть что-то необычное, и вот вам экзотический вариант:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> checkEmail <span class="op">=</span> (email) <span class="kw">=&gt;</span> {</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> input <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="vs">`INPUT`</span>)<span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  input<span class="op">.</span><span class="at">type</span> <span class="op">=</span> <span class="vs">`email`</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  input<span class="op">.</span><span class="at">value</span> <span class="op">=</span> email<span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> input<span class="op">.</span><span class="fu">checkValidity</span>()<span class="op">;</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span></code></pre></div>
<p>Вам может показаться, что здесь нет регулярных выражений, и это правда. В коде явно нет. Но вы запрашиваете валидацию через поле формы, которое по умолчанию обращается к регулярному выражению в самом браузере.</p>
<hr />
<p>Точность — не всегда хорошо. Если вы не валидируете счёт, на который вам поступает зарплата, то смело можно писать более простые правила. Перфекционизм — всегда затратно.</p>
</div>
</section>
<section id="скорость-выполнения" class="level2" data-number="7.3">
<h2 data-number="7.3">7.3. Скорость выполнения</h2>
<div class="text-container text-container--module">
<p>Последний пример из предыдущей главы подвёл нас к ещё одному важному вопросу, который входит в понятие эффективности — скорость выполнения.</p>
<blockquote>
<p>Нужно ли использовать регулярное выражение везде при работе с текстом?</p>
</blockquote>
<p>— Нет, не нужно!</p>
<p>Хотя наш курс называется «Регулярные выражения» и мы должны их хвалить, но всегда следует подходить к решению с холодной головой и обязательно тестировать, сравнивая с другими вариантами решения.</p>
<p>Для примера возьмём одну из уже знакомых нам функций, возвращающую правую часть строки, и замерим производительность:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> COUNT <span class="op">=</span> <span class="dv">10000</span><span class="op">;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> rightMatch <span class="op">=</span> (str<span class="op">,</span> anchor) <span class="kw">=&gt;</span> {</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="op">!</span>str <span class="op">||</span> <span class="op">!</span>anchor) {</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> str<span class="op">;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> regex <span class="op">=</span> <span class="kw">new</span> <span class="bu">RegExp</span>(<span class="vs">`^.*?</span><span class="sc">${</span>anchor<span class="sc">}</span><span class="vs">(.*?)$`</span>)<span class="op">;</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> str<span class="op">.</span><span class="fu">replace</span>(regex<span class="op">,</span> (source<span class="op">,</span> $1) <span class="kw">=&gt;</span> $1 <span class="op">?</span> $1 <span class="op">:</span> source)<span class="op">;</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> time <span class="op">=</span> <span class="bu">performance</span><span class="op">.</span><span class="fu">now</span>()<span class="op">;</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> COUNT<span class="op">;</span> i<span class="op">++</span>) {</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rightMatch</span>(<span class="vs">`12:01, 14:05, 18:00, 21:20 |  Спортивные новости`</span><span class="op">,</span> <span class="vs">`|</span><span class="sc">\\</span><span class="vs">s+`</span>)<span class="op">;</span>  </span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> <span class="bu">performance</span><span class="op">.</span><span class="fu">now</span>() <span class="op">-</span> time<span class="op">;</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&#39;Время выполнения = &#39;</span><span class="op">,</span> time)<span class="op">;</span> <span class="co">// 18 миллисекунд</span></span></code></pre></div>
<p>А теперь напишем ту же функцию, только стандартными методами JavaScript:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> COUNT <span class="op">=</span> <span class="dv">10000</span><span class="op">;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> rightMatch <span class="op">=</span> (str<span class="op">,</span> anchor) <span class="kw">=&gt;</span> {</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="op">!</span>str <span class="op">||</span> <span class="op">!</span>anchor) {</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> str<span class="op">;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> str<span class="op">.</span><span class="fu">substr</span>(str<span class="op">.</span><span class="fu">indexOf</span>(anchor) <span class="op">+</span> anchor<span class="op">.</span><span class="at">length</span>)<span class="op">;</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> time <span class="op">=</span> <span class="bu">performance</span><span class="op">.</span><span class="fu">now</span>()<span class="op">;</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> COUNT<span class="op">;</span> i<span class="op">++</span>) {</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rightMatch</span>(<span class="vs">`12:01, 14:05, 18:00, 21:20 |  Спортивные новости`</span><span class="op">,</span> <span class="vs">`|  `</span>)<span class="op">;</span>  </span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> <span class="bu">performance</span><span class="op">.</span><span class="fu">now</span>() <span class="op">-</span> time<span class="op">;</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&#39;Время выполнения = &#39;</span><span class="op">,</span> time)<span class="op">;</span> <span class="co">// 4.2 миллисекунды</span></span></code></pre></div>
<p>Мы производили измерения на одинаковом количестве повторений в цикле <code>10000</code> двумя разными способами:</p>
<ul>
<li>с помощью регулярного выражения,</li>
<li>с помощью методов работы с подстрокой.</li>
</ul>
<p>Результат получился закономерным: <strong>18</strong> против <strong>4.2</strong> миллисекунды. Это доказывает, что <strong>регулярные выражения работают медленнее</strong> нативных методов.</p>
<p>Стоит отметить, что на разных компьютерах и операционных системах результат выполнения примеров будет отличаться, но тренд в разности скорости сохранится.</p>
<blockquote>
<p>Так почему же стоит использовать регулярные выражения?</p>
</blockquote>
<p>Для упрощения примера мы намеренно изменили исходную строку <code>12:01, 14:05, 18:00, 21:20 | Спортивные новости</code>. Добавили туда якорный символ <code>|</code>, чтобы было легче написать ответную нативную функцию.</p>
<p>А теперь представьте, что будет, если убрать якорь <code>|</code> и как в изначальном примере искать по последнему времени, точного значения которого мы не знаем?</p>
<p><code>12:01, 14:05, 18:00, 21:20 Спортивные новости</code></p>
<p>Вы можете парировать, что можно искать по цифре, а если так?</p>
<p><code>12:01, 14:05, 18:00, 21:20 26 Бакинских комиссаров</code></p>
<p>Каждое подобное изменение будет обходиться вам дорого с точки зрения затраченного времени на написание функции. К тому же не так много задач, которые требуют перебора настолько большого объема строк.</p>
<hr />
<p>Выбор технологии и алгоритма решения — это всегда баланс нескольких факторов. Регулярные выражения — всего лишь инструмент.</p>
</div>
</section>
<section id="каскады-правил" class="level2" data-number="7.4">
<h2 data-number="7.4">7.4. Каскады правил</h2>
<div class="text-container text-container--module">
<p>Мы рассмотрели сложный пример регулярного выражения проверки адреса электронной почты. В этом примере мы были вынуждены составить очень сложную и громоздкую конструкцию. Но это скорее исключение из правил.</p>
<p>Во многих задачах можно разбить одно большое правило на <strong>каскад</strong> (несколько) маленьких. Они в сумме будут давать тот же результат, но при этом станут расходовать меньше памяти и будут эффективнее по скорости выполнения.</p>
<p>Каждое правило каскада получает результат работы предыдущего, обрабатывает и передаёт дальше, пока не будут выполнены все правила.</p>
<p>Мы с вами уже решали похожую задачу с расстановкой абзацных тегов:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> setParagraph <span class="op">=</span> (str) <span class="kw">=&gt;</span> (str) <span class="op">?</span> <span class="vs">`&lt;p&gt;</span><span class="sc">${</span>str<span class="op">.</span><span class="fu">replace</span>(<span class="ss">/</span><span class="sc">\n{2,}</span><span class="ss">/g</span><span class="op">,</span> <span class="st">&#39;&lt;/p&gt;&lt;p&gt;&#39;</span>)<span class="op">.</span><span class="fu">replace</span>(<span class="ss">/</span><span class="sc">\n</span><span class="ss">/g</span><span class="op">,</span> <span class="st">&#39;&lt;br&gt;&#39;</span>)<span class="sc">}</span><span class="vs">&lt;/p&gt;`</span><span class="op">:</span> str<span class="op">;</span></span></code></pre></div>
<p>Здесь используется каскад из двух правил. Сперва захватываются два и более подряд переводов строк <code>\n</code> и заменяются на <code>&lt;/p&gt;&lt;p&gt;</code>. Затем, после первой замены, результат передаётся следующему правилу, которое заменяет оставшиеся одиночные переводы строки на <code>&lt;br&gt;</code>.</p>
<p>При написании каскадов, как и в примере выше, важен порядок следования. Если мы поменяем правила местами, то получим совсем другой результат.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> setParagraph <span class="op">=</span> (str) <span class="kw">=&gt;</span> (str) <span class="op">?</span> <span class="vs">`&lt;p&gt;</span><span class="sc">${</span>str<span class="op">.</span><span class="fu">replace</span>(<span class="ss">/</span><span class="sc">\n</span><span class="ss">/g</span><span class="op">,</span> <span class="st">&#39;&lt;br&gt;&#39;</span>)<span class="op">.</span><span class="fu">replace</span>(<span class="ss">/</span><span class="sc">\n{2,}</span><span class="ss">/g</span><span class="op">,</span> <span class="st">&#39;&lt;/p&gt;&lt;p&gt;&#39;</span>)<span class="sc">}</span><span class="vs">&lt;/p&gt;`</span><span class="op">:</span> str<span class="op">;</span></span></code></pre></div>
<p>Все переводы строк заменятся на <code>&lt;br&gt;</code>, а двойные и более переводы строк не совпадут ни с чем.</p>
<p>Можно написать более универсальное правило, которое построчно обернёт абзацы:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> setParagraph <span class="op">=</span> (str) <span class="kw">=&gt;</span> (str) <span class="op">?</span> str<span class="op">.</span><span class="fu">replace</span>(<span class="ss">/</span><span class="sc">^(</span><span class="ss">.</span><span class="sc">*?)$</span><span class="ss">/gm</span><span class="op">,</span> <span class="st">&#39;&lt;p&gt;$1&lt;/p&gt;&#39;</span>) <span class="op">:</span> str<span class="op">;</span></span></code></pre></div>
<p>У данного решения есть две проблемы:</p>
<ul>
<li>не решён вопрос с одиночными переводами строк,</li>
<li>скобки будут сохранять текст в памяти прежде чем оборачивать тегами, и это может быть очень ресурсоемкой операцией, особенно на больших объемах текста.</li>
</ul>
<p>Чтобы правило заработало корректно, придётся усложнить его. В итоге мы можем получить нечто похожее на правило валидации электронной почты.</p>
<p>Не пытайтесь разложить всю задачу в одном регулярном выражении, это может оказаться неэффективно.</p>
<p><strong>Типограф</strong></p>
<p>Ярким примером «каскада» (да и в целом задачи, основанной на регулярных выражениях) можно назвать «Типограф».</p>
<blockquote>
<p>Типограф — это средство онлайн подготовки текста к веб-изданию. Он помогает избежать монотонной корректировки, расстановки кавычек, неразрывных пробелов, специальных символов, исправляет некоторые ошибки ввода (опечатки) и выполняет другие задачи. В его основе собрано около 200 правил экранной типографики и книжной вёрстки.</p>
</blockquote>
<p>Если вы раньше не сталкивались с этим сервисом, вот небольшой пример его работы:</p>
<p><strong>Исходный текст:</strong></p>
<p><code>...Когда В. И. Пупкин увидел в газете ( это была "Сермяжная правда" № 45) рубрику Weather Forecast(r), он не поверил своим глазам - температуру обещали +-451F.</code></p>
<p><strong>Результат обработки в виде кода:</strong></p>
<p><code>&lt;p&gt;&amp;hellip;Когда &lt;nobr&gt;В. И. Пупкин&lt;/nobr&gt; увидел в&amp;nbsp;газете (это была &amp;laquo;Сермяжная правда&amp;raquo; &amp;#8470;&amp;nbsp;45) рубрику Weather Forecast&lt;sup&gt;&lt;small&gt;&amp;reg;&lt;/small&gt;&lt;/sup&gt;, он&amp;nbsp;не&amp;nbsp;поверил своим глазам&amp;nbsp;&amp;mdash; температуру обещали &amp;plusmn;&lt;nobr&gt;451 &amp;deg;F&lt;/nobr&gt;.&lt;/p&gt;</code></p>
<p><strong>Результат обработки в виде текста:</strong></p>
<p>…Когда В. И. Пупкин увидел в газете (это была «Сермяжная правда» № 45) рубрику Weather Forecast®, он не поверил своим глазам — температуру обещали ±451 °F.</p>
<p><strong>Вот что сделал Типограф:</strong></p>
<ul>
<li>расставил абзацные теги;</li>
<li>заменил три отдельные точки на символ многоточия;</li>
<li>связал в неразрывную конструкцию инициалы и фамилию, чтобы они переносились на новую строку целиком;</li>
<li>привязал союзы и предлоги, чтобы они всегда переносились на новую строку со следующим словом;</li>
<li>удалил пробелы внутри скобок;</li>
<li>заменил кавычки в виде классических <code>"</code> дюймов на принятые в русском «ёлочки»;</li>
<li>привязал символ № к числу неразрывным пробелом;</li>
<li>заменил <code>(r)</code> на символ зарегистрированного товарного знака <code>(r)</code>, сделал его меньше основного кегля и выровнял по верхней границе;</li>
<li>заменил дефис <code>-</code> на длинное тире <code>—</code> и привязал его к предыдущему слову;</li>
<li>заменил знак «плюс-минус» <code>+-451F</code> на <code>±451 °F</code> и связал в неразрывную конструкцию.</li>
</ul>
<p>Если вы верстаете регулярно, то понимаете, насколько трудно бывает вручную отлавливать и исправлять все эти моменты.</p>
<p>Мы хотим вам помочь, пользуйтесь: <a href="https://typograf.ru">https://typograf.ru</a></p>
<hr />
<p>Что мы должны вынести из темы оптимизации: истина находится где-то посередине. Не существует единого и универсального рецепта, который решит все ваши проблемы. Полагаться стоит только на полученный опыт и тестирование.</p>
</div>
</section>
<section id="регулярные-выражения-в-среде-окружения" class="level2" data-number="7.5">
<h2 data-number="7.5">7.5. Регулярные выражения в среде окружения</h2>
<div class="text-container text-container--module">
<p>Мы изучили основную теоретическую часть регулярных выражений, осталось добавить несколько практических примеров использования.</p>
<p>Возможно, вы обращали внимание, а если нет, то после этой главы обязательно обратите, что поиск и замена текста с помощью регулярных выражений есть в большинстве редакторов.</p>
<ul>
<li>MS Word,</li>
<li>LibreOffice,</li>
<li>NeoOffice,</li>
<li>Atom,</li>
<li>Visual Studio Code (VS Code),</li>
<li>Sublime,</li>
<li>WebStorm</li>
<li>и многих других…</li>
</ul>
<p>Искать регулярные выражения нужно в интерфейсе поиска и замены, а выглядит это примерно так:</p>
<p><strong>VS Code</strong></p>
<p><img src="../media/file5.png" /></p>
<p><strong>Atom</strong></p>
<p><img src="../media/file6.png" /></p>
<p><strong>NeoOffice</strong></p>
<p><img src="../media/file7.png" /></p>
<p>При зажигании соответствующего флага ваша строка начинает восприниматься как регулярное выражение, и дальше вы можете применять полученные в ходе курса знания.</p>
<p>Стоит отметить, что большинство из того, что мы изучали, справедливо в редакторах, но могут быть и особенности. Поэтому обязательно ознакомьтесь с таблицей поддерживаемых селекторов того редактора, с которым работаете.</p>
<p>Часто бывает так, что некоторые символьные селекторы работают не так, как в JavaScript.</p>
<p>Например, <code>\w</code> может совпадать с русскими буквами или может не включать в себя цифры и символ подчеркивания. Но мы же с вами уже знаем, что любой символьный селектор можно заменить квадратными скобками с набором символов, поэтому это не должно стать проблемой.</p>
<p>Какие задачи можно решать с помощью регулярных выражений в текстовых редакторах? Вот основной перечень задач:</p>
<ul>
<li><strong>поиск и гибкая замена с сохранением состояния текста</strong>,</li>
<li><strong>подготовка, обработка данных</strong>,</li>
<li><strong>написание кода</strong>.</li>
</ul>
<p>Давайте пройдём по этим задачам и посмотрим, как можно упростить себе жизнь.</p>
<p><strong>Поиск и замена</strong></p>
<p>В процессе создания этого курса выяснилось, что разметка MarkDown, с помощью которой написаны статьи, конфликтует с частями регулярного выражения и заменяет их. Чтобы избавиться от проблемы, нужно было обернуть регулярные выражения в бэктики.</p>
<p><img src="../media/file8.png" /></p>
<p>Делать это вручную весьма скучно, долго, да и можно что-то упустить. Поэтому самое время заставить компьютер работать за нас.</p>
<p><img src="../media/file9.png" /></p>
<p>Посмотрите внимательно на скриншот. В синем круге обведены регулярное выражение <code>\*\*(.+?)\*\*</code> и выражение замены со вставкой сохранённого состояния круглых скобок <code>$1</code>.</p>
<p>Для уточнения мы могли бы добавить выражение начала строки. Но как видно на скриншоте (обведено зеленым), оно и так совпало с тем, что мы ожидали.</p>
<p><img src="../media/file10.png" /></p>
<blockquote>
<p>Только задумайтесь, мы написали регулярное выражение, чтобы исправить ошибку регулярного выражения MarkDown-разметки в статье про регулярные выражения 🤪</p>
</blockquote>
<p>В результате с помощью замены во всем документе всего лишь за несколько кликов можно выполнить работу, которая заняла бы немало времени, если бы мы всё делали вручную.</p>
<p><strong>Подготовка, обработка данных</strong></p>
<p>Вспомните, в одном из разделов мы решали задачу по подготовке номеров мобильных телефонов для отправки СМС.</p>
<p>Эта задача возникла из практического примера, где помимо неверно записанных номеров попадались ещё и пропущенные строки, короткие записи городских номеров, невалидные 12-ти значные номера. Файл имел размер в несколько мегабайтов, и приводить его в порядок вручную было бы непросто.</p>
<p><img src="../media/file11.png" /></p>
<p>Решить задачу «в лоб», как в первом случае, здесь не получится. У нас совершенно разные маленькие задачи, и здесь нам понадобится «каскад» правил с одной лишь разницей: записывать и применять их будем поочерёдно.</p>
<p>Первое, что мы сделаем — избавимся от пустых строк. Для этого напишем простое правило <code>^\n</code> и заменим на ничего.</p>
<p><img src="../media/file12.png" /></p>
<p>Затем удалим все номера длиннее 11 знаков с помощью правила <code>^\d{12,}\n</code>. Здесь важно включать селектор начала строки <code>^</code> как якорь и перевода строки <code>\n</code>, чтобы при замене не оставалось пустых строк.</p>
<p><img src="../media/file13.png" /></p>
<p>Следующим шагом удалим все городские номера короче 11 знаков с помощью правила <code>^\d{1,10}\n</code>.</p>
<p><img src="../media/file14.png" /></p>
<p>И теперь заменим все восьмёрки в начале строки на семёрки, потому что правильный код страны России — <code>7</code>.</p>
<p><img src="../media/file15.png" /></p>
<blockquote>
<p>Все совпадения номеров мобильных телефонов в примере с действующими номерами случайны!</p>
</blockquote>
<p>В результате за пару минут с помощью практического применения регулярных выражений мы подготовили большой файл с данными.</p>
<p><strong>Написание кода</strong></p>
<p>При разработке часто приходится писать похожие конструкции, у которых изменяемая часть хотя и незначительна, но требует большого количества копипасты и внимательной доводки руками.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> renderCard <span class="op">=</span> ({title<span class="op">,</span> timeIn<span class="op">,</span> timeOut<span class="op">,</span> type<span class="op">,</span> guests<span class="op">,</span> rooms}) <span class="kw">=&gt;</span> {</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> newCardElement <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">cloneNode</span>(<span class="kw">true</span>)<span class="op">;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// выбрать все элементы внутри склонированной ноды с соответствующими классами и вставить значения через textContent</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span></code></pre></div>
<blockquote>
<p>Пример взят из курса «JavaScript. Профессиональная разработка веб-интерфейсов», проект «Кексобукинг».</p>
</blockquote>
<p>Чтобы облегчить себе жизнь, мы скопируем параметры из функции и будем строить выражение от одной строки:</p>
<p><img src="../media/file16.png" /></p>
<blockquote>
<p><strong>Маленький лайфхак</strong>: иногда строить регулярное выражение для фрагмента текста очень сложно. Оно постоянно совпадает с чем-то лишним, а нужно, чтобы оно сработало в ограниченной части строки. На помощь приходит флаг «<strong>найти в выделенной области</strong>». Он тоже присутствует во многих редакторах. Выделите текст и применяйте регулярное выражение только внутри выделения.</p>
</blockquote>
<p>Так мы и поступим. Вставим параметры, добавим лишнюю запятую в конце, чтобы не усложнять выражение, и заменим сохранённые скобки <code>(\w+)</code> на <code>\tnewCardElement.querySelector('.card-$1').textContent = $1;\n</code>.</p>
<p>Обращаем внимание, что спереди мы поставили символ табуляции <code>\t</code>, а сзади — перевод строки <code>\n</code>, чтобы не только вставить код, но и сразу отформатировать его.</p>
<p><img src="../media/file17.png" /></p>
<p>Пример может показаться очень синтетическим, но он хорошо отражает суть. Достаточно часто в практике приходится переписывать поля из одной структуры в другую, и от этой рутины всегда можно избавиться.</p>
<p><strong>Где ещё встречаются?</strong></p>
<p>Сейчас регулярные выражения интегрированы практически во все средства разработки, а также:</p>
<ul>
<li>в языки программирования,</li>
<li>в базы данных,</li>
<li>в системные утилиты,</li>
<li>в настройки серверов</li>
<li>и много куда ещё…</li>
</ul>
<p>Некоторые языки программирования и программные продукты не полностью поддерживают список селекторов или, наоборот, поддерживают гораздо больше, чем мы изучили.</p>
<blockquote>
<p>К слову, поддержка регулярных выражений в языке JavaScript не самая широкая.</p>
</blockquote>
<p>Везде есть свои нюансы использования регулярных выражений, но в целом знания, полученные на курсе, позволят вам с легкостью адаптироваться к любым новым условиям.</p>
<p>Напоследок, чтобы вы больше практиковались в регулярных выражениях, рекомендуем пару удобных онлайн сервисов:</p>
<ul>
<li><a href="https://regex101.com/">https://regex101.com/</a></li>
<li><a href="https://regexr.com/">https://regexr.com/</a></li>
</ul>
<hr />
<p>Регулярные выражения получили своё практическое признание в огромном количестве программных продуктов. Надеемся, что и вы им найдёте достойное применение!</p>
</div>
</section>
<section id="финальный-тест-по-программе-курса" class="level2" data-number="7.6">
<h2 data-number="7.6">7.6. Финальный тест по программе курса</h2>
<div class="text-container text-container--module">
<p>Повторим основные моменты, которые были рассмотрены на курсе.</p>
<ol type="1">
<li><strong>С каким типом данных работает регулярное выражение?</strong></li>
</ol>
<ul>
<li>Любым.</li>
<li>Числами, строками, датами.</li>
<li>Только со строками.</li>
</ul>
<ol start="2" type="1">
<li><strong>Какова основная задача, решаемая с помощью регулярных выражений?</strong></li>
</ol>
<ul>
<li>Поиск подстроки в строке с «плавающими» данными.</li>
<li>Валидация данных формы и ограничение ввода.</li>
</ul>
<ol start="3" type="1">
<li><strong>С чем совпадёт [а-яa-z]?</strong></li>
</ol>
<ul>
<li>С любой буквой.</li>
<li>С любыми буквами в нижнем регистре.</li>
<li>С буквой русского и английского алфавита в нижнем регистре.</li>
</ul>
<ol start="4" type="1">
<li><strong>Включает ли символьный селектор `\w` цифры?</strong></li>
</ol>
<ul>
<li>Нет не включает.</li>
<li>Да, включает вместе с символом `_`.</li>
<li>Да, включает без символа `_`.</li>
</ul>
<ol start="5" type="1">
<li><strong>С чем совпадёт паттерн: `\d+.\d+`?</strong></li>
</ol>
<ul>
<li>Дробные числа.</li>
<li>Дробные числа, целые числа и числа, между которыми стоит любой символ, кроме `\n`.</li>
<li>Целые и дробные числа.</li>
</ul>
<ol start="6" type="1">
<li><strong>Как правильно записать регулярное выражение `любое целое число` через конструктор?</strong></li>
</ol>
<ul>
<li>`new RegExp(‘\d+’)`</li>
<li>`new RegExp(‘\\d+’)`</li>
<li>`new RegExp(‘\\d’, ‘g’)`</li>
</ul>
<ol start="7" type="1">
<li><strong>Какое из отрицаний в паттерне говорит «совпасть с не числом»?</strong></li>
</ol>
<ul>
<li>`\D`</li>
<li>`[^0-9]`</li>
<li>`\d?`</li>
</ul>
<ol start="8" type="1">
<li><strong>Как записать квантификатор `*` с помощью численного квантификатора?</strong></li>
</ol>
<ul>
<li>`x{1,}`</li>
<li>`x{0,∞}`</li>
<li>`x{0,}`</li>
</ul>
<ol start="9" type="1">
<li><strong>В регулярном выражении `.*?` квантификатор `*` «жадный» или «ленивый»?</strong></li>
</ol>
<ul>
<li>Жадный.</li>
<li>Ленивый.</li>
</ul>
<ol start="10" type="1">
<li><strong>Как называется проверка в выражении `\.(?!$)`?</strong></li>
</ol>
<ul>
<li>Опережающая позитивная.</li>
<li>Ретроспективная позитивная.</li>
<li>Опережающая негативная.</li>
<li>Ретроспективная негативная.</li>
</ul>
</div>
</section>
<section id="финальный-тест-по-программе-курса-ответы" class="level2" data-number="7.7">
<h2 data-number="7.7">7.6. Финальный тест по программе курса (ответы)</h2>
<div class="text-container text-container--module">
<ol type="1">
<li><strong>С каким типом данных работает регулярное выражение?</strong></li>
</ol>
<ul>
<li>Только со строками.</li>
</ul>
<ol start="2" type="1">
<li><strong>Какова основная задача, решаемая с помощью регулярных выражений?</strong></li>
</ol>
<ul>
<li>Поиск подстроки в строке с «плавающими» данными.</li>
</ul>
<ol start="3" type="1">
<li><strong>С чем совпадёт [а-яa-z]?</strong></li>
</ol>
<ul>
<li>С буквой русского и английского алфавита в нижнем регистре.</li>
</ul>
<ol start="4" type="1">
<li><strong>Включает ли символьный селектор `\w` цифры?</strong></li>
</ol>
<ul>
<li>Да, включает вместе с символом `_`.</li>
</ul>
<ol start="5" type="1">
<li><strong>С чем совпадёт паттерн: `\d+.\d+`?</strong></li>
</ol>
<ul>
<li>Дробные числа, целые числа и числа, между которыми стоит любой символ, кроме `\n`.</li>
</ul>
<ol start="6" type="1">
<li><strong>Как правильно записать регулярное выражение `любое целое число` через конструктор?</strong></li>
</ol>
<ul>
<li>`new RegExp(‘\\d+’)`</li>
<li>`new RegExp(‘\\d’, ‘g’)`</li>
</ul>
<ol start="7" type="1">
<li><strong>Какое из отрицаний в паттерне говорит «совпасть с не числом»?</strong></li>
</ol>
<ul>
<li>`\D`</li>
<li>`[^0-9]`</li>
</ul>
<ol start="8" type="1">
<li><strong>Как записать квантификатор `*` с помощью численного квантификатора?</strong></li>
</ol>
<ul>
<li>`x{0,}`</li>
</ul>
<ol start="9" type="1">
<li><strong>В регулярном выражении `.*?` квантификатор `*` «жадный» или «ленивый»?</strong></li>
</ol>
<ul>
<li>Ленивый.</li>
</ul>
<ol start="10" type="1">
<li><strong>Как называется проверка в выражении `\.(?!$)`?</strong></li>
</ol>
<ul>
<li>Опережающая негативная.</li>
</ul>
</div>
</section>
</section>
</body>
</html>
