<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="ru-RU">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch005.xhtml</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="d-в-css-и-параллакс-эффект" class="level1" data-number="5">
<h1 data-number="5">5. 3D в CSS и параллакс-эффект</h1>
<div class="text-container text-container--module">
<p>В пятом разделе мы узнаем, что такое эффект параллакса и как его можно добиться с помощью JavaScript. Поговорим также о 3D в CSS и научимся делать эффектные объёмные анимации.</p>
</div>
<section id="что-такое-параллакс" class="level2" data-number="5.1">
<h2 data-number="5.1">5.1. Что такое параллакс</h2>
<div class="text-container text-container--module">
<p>Сам по себе эффект параллакса был изначально описан в астрономии. Он означает изменение видимого положения объекта относительно удалённого фона в зависимости от положения наблюдателя. Например, движение солнца по небу в течение дня или смещение звёзд на ночном небе.</p>
<p>Чем дальше от наблюдателя объект, тем медленнее он движется, а чем ближе — тем быстрее.</p>
<figure>
<img src="../media/file82.jpg" alt="Схема параллакса" />
<figcaption aria-hidden="true">Схема параллакса</figcaption>
</figure>
<p>В нашем случае в веб-разработке параллакс помогает добавить глубину для страницы, создать иллюзию объёма и движения в пространстве.</p>
<p>Параллакс-эффект создаётся за счёт того, что чем ближе к нам объекты, тем быстрее для нас они проносятся мимо во время нашего движения. И наоборот, чем дальше находятся объекты, тем медленнее они проносятся. То есть речь идёт об объектах, которые находятся в состоянии покоя в пространстве и не перемещаются в пространстве сами. Только зритель перемещается в пространстве.</p>
<p>Вот несколько примеров:</p>
<p><a href="https://dribbble.com/shots/13961411-Breathtaking">Источник</a></p>
<p><a href="https://dribbble.com/shots/14158190-Homepage-Web-Design-for-Ecodenta">Источник</a></p>
<p><a href="https://dribbble.com/shots/14712672-Landing-page-web-design-interactions-for-Qoorio">Источник</a></p>
<p><a href="https://dribbble.com/shots/16139551-Food-Delivery-Website">Источник</a></p>
<p>Фон движется медленнее, а элемент поверх него — быстрее. Элементов может быть любое количество.</p>
</div>
</section>
<section id="события-мыши-mousemove-mouseover-mouseout" class="level2" data-number="5.2">
<h2 data-number="5.2">5.2. События мыши mousemove, mouseover, mouseout</h2>
<div class="text-container text-container--module">
<p>Мы узнали, что такое параллакс. Теперь давайте посмотрим, чем может быть полезен JavaScript для его реализации.</p>
<p>Для параллакса мы можем использовать разные варианты событий, на которые можно навесить эффект. Это может быть прокрутка страницы, как мы рассмотрели в прошлом модуле. На мобильных устройствах это может быть прикосновение или наклон устройства. В этом модуле мы познакомимся и поработаем с движением курсора.</p>
<p>И в этом нам помогут события движения мыши:</p>
<ul>
<li><p><code>mousemove</code> — наступает при перемещении курсора по элементу.</p></li>
<li><p><code>mouseover</code> — наступает, если пользователь наводит курсор на сам элемент либо его вложенные элементы.</p></li>
<li><p><code>mouseout</code> — наступает, если курсор «ушёл» за границы элемента.</p></li>
<li><p><code>mouseleave</code> — наступает, если курсор «ушёл» за пределы элемента.</p></li>
</ul>
<p>Последние два события очень похожи между собой. Разница лишь в том, что первое событие не всплывает, а второе — всплывает.</p>
<p>В отличие от остальных, <code>mousemove</code> срабатывает каждый раз, когда курсор движется, оставаясь в пределах элемента.</p>
<p>Ими мы будем пользоваться в дальнейших задачах.</p>
</div>
</section>
<section id="параллакс-эффект-страницы-404" class="level2" data-number="5.3">
<h2 data-number="5.3">5.3. Параллакс-эффект страницы 404</h2>
<div class="text-container text-container--module">
<p>Рассмотрим пример, как можно оживить страницу с ошибкой 404 за счёт параллакс-эффекта при движении мыши.</p>
<figure>
<img src="../media/file83.gif" alt="Параллакс-эффект страницы 404" />
<figcaption aria-hidden="true">Параллакс-эффект страницы 404</figcaption>
</figure>
<p>Для указания скорости добавим каждому слою data-атрибут <code>data-speed</code>. Чем он больше, тем движение будет быстрее, чем меньше — тем медленнее. Дальние слои с волнами будут смещаться медленнее всех (<code>data-speed="0.02"</code>). Слой со значком внимания — чуть быстрее (<code>data-speed="0.04"</code>). Верхние слои с оградой и деревом — быстрее всех (<code>data-speed="0.1"</code>).</p>
<p>Будем считать, что когда курсор находится в центре экрана, смещение будет нулевым.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">//размер области просмотра</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> parallaxWidth <span class="op">=</span> parallaxBox<span class="op">.</span><span class="at">offsetWidth</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> parallaxHeight <span class="op">=</span> parallaxBox<span class="op">.</span><span class="at">offsetHeight</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">// координаты центра экрана</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> coordX <span class="op">=</span> evt<span class="op">.</span><span class="at">clientX</span> <span class="op">-</span> parallaxWidth <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> coordY <span class="op">=</span> evt<span class="op">.</span><span class="at">clientY</span> <span class="op">-</span> parallaxHeight <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span></code></pre></div>
<p>Чем дальше курсор движется к краю экрана, тем больше смещение. Смещать элементы будем при помощи трансформации сдвига по осям X и У. Большого количества знаков после запятой не нужно, хватит и двух.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>layers<span class="op">.</span><span class="fu">forEach</span>((layer)<span class="kw">=&gt;</span>{</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> layerSpeed <span class="op">=</span> layer<span class="op">.</span><span class="at">dataset</span><span class="op">.</span><span class="at">speed</span><span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> x <span class="op">=</span> (coordX <span class="op">*</span> layerSpeed)<span class="op">.</span><span class="fu">toFixed</span>(<span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> y <span class="op">=</span> (coordY <span class="op">*</span> layerSpeed)<span class="op">.</span><span class="fu">toFixed</span>(<span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    layer<span class="op">.</span><span class="fu">setAttribute</span>(<span class="st">&#39;style&#39;</span><span class="op">,</span> <span class="vs">`transform: translate(</span><span class="sc">${</span>x<span class="sc">}</span><span class="vs">px, </span><span class="sc">${</span>y<span class="sc">}</span><span class="vs">px);`</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  })<span class="op">;</span></span></code></pre></div>
<p>Далее с помощью JavaScript будем смещать каждый слой при движении мыши по экрану. В этом нам поможет событие <code>mousemove</code>, которое будем слушать на родителе параллакс-слоёв. А callback-функция <code>parallax</code> как раз будет содержать всё описанное выше.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>parallaxBox<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&#39;mousemove&#39;</span><span class="op">,</span> parallax)<span class="op">;</span></span></code></pre></div>
<p>Чтобы элементы возвращались в исходное состояние, когда курсор движется за пределами страницы, добавим ещё один слушатель события <code>mouseout</code>. В нём будем удалять инлайновые стили со смещением.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> stopParallax <span class="op">=</span> (evt) <span class="kw">=&gt;</span> {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  layers<span class="op">.</span><span class="fu">forEach</span>((layer)<span class="kw">=&gt;</span>{</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    layer<span class="op">.</span><span class="fu">removeAttribute</span>(<span class="st">&#39;style&#39;</span>)<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>parallaxBox<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&#39;mouseout&#39;</span><span class="op">,</span> stopParallax)<span class="op">;</span></span></code></pre></div>
</div>
</section>
<section id="css-свойства-для-работы-с-3d" class="level2" data-number="5.4">
<h2 data-number="5.4">5.4. CSS-свойства для работы с 3D</h2>
<div class="text-container text-container--module">
<p>Помимо классического параллакса, есть более эффективный с точки зрения производительности способ создавать объёмные эффекты за счёт CSS — это свойства 3D-трансформаций.</p>
<p>Для выполнения преобразований CSS в трёхмерном пространстве нам нужно начать с настройки 3D-пространства, придав ему перспективу. После этого нужно настроить, как 2D-элементы будут себя вести в этом пространстве. Для этого будем использовать свойство <code>transform-style</code> и его значение <code>preserve-3d</code>: свойство устанавливает, что дочерние элементы будут располагаться в трёхмерном пространстве. Значение по умолчанию — <code>flat</code>, то есть элементы лежат в одной плоскости.</p>
<section id="перспектива" class="level3" data-number="5.4.1">
<h3 data-number="5.4.1">Перспектива</h3>
<p><code>perspective</code> — перспектива. Она определяет расстояние между плоскостью <code>z = 0</code> и пользователем. Это помогает создать объёмный эффект. Элемент, размещённый на оси Z со значением <code>&gt; 0</code>, будет выглядеть больше (ближе к пользователю). Если значение <code>&lt; 0</code>, он будет выглядеть меньше (дальше от пользователя).</p>
<p>Если Z-координата больше значения перспективы, то это означает, что объект оказался за пользователем, поэтому он не будет отрисован на странице.</p>
<p>Чем меньше глубина перспективы, тем ближе наблюдающий к объекту. Чем больше — тем дальше. Представьте, что перед вами пятиэтажный дом и вы стоите от него в пяти метрах. А потом в 500 метрах. Это и есть разница в глубине перспективы.</p>
<p><code>perspective-origin</code> — точка схождения перспективы. Это точка, в которой сходятся параллельные линии предмета. По умолчанию расположена в центре элемента, но её можно переместить.</p>
<figure>
<img src="../media/file84.jpg" alt="perspective" />
<figcaption aria-hidden="true">perspective</figcaption>
</figure>
<p>Значение <code>perspective-origin</code> может принимать те же значения, что и точка трансформации элемента <code>transform-origin</code>:</p>
<figure>
<img src="../media/file85.png" alt="perspective-origin" />
<figcaption aria-hidden="true">perspective-origin</figcaption>
</figure>
<p>Посмотрите на примере куба, как меняется его внешний вид в зависимости от точки перспективы:</p>
<p><em>(см. 5.15. Демонстрация изменения точки схождения перспективы)</em></p>
</section>
<section id="d-трансформации-1" class="level3" data-number="5.4.2">
<h3 data-number="5.4.2">3D-трансформации</h3>
<p>Помимо известных и уже используемых нами трансформаций в плоскости X-Y, нам понадобятся аналогичные в плоскости Z:</p>
<ul>
<li><p><code>rotateZ()</code> — поворот элемента вдоль оси Z, что аналогично <code>rotate()</code>.</p></li>
<li><p><code>scaleZ()</code> — масштабирует элемент по оси Z. Эффект будет заметен только при использовании других трёхмерных преобразований: перспективы, поворота элемента по осям X или Y, смещения элемента по оси Z.</p></li>
<li><p><code>translateZ()</code> — сдвигает элемент по оси Z. Эффект будет заметен только при использовании перспективы, поворота элемента по осям X или Y.</p></li>
</ul>
<p>Вы могли заметить, что в этом списке нет четвёртой функции 2D-трансформаций — <code>skew</code>. Она невозможна в направлении Z, поэтому отсутствует её 3D-представление.</p>
<p>Посмотрим на примере, как будут применяться эти трансформации в движении:</p>
<p><em>(см. 5.16. Демонстрация изменения свойств трансформации по оси Z)</em></p>
<p>То же самое можно записать с помощью 3D-функций:</p>
<ul>
<li><code>rotate3D(x, y, z, a)</code>.</li>
</ul>
<p><code>rotateZ(a) = rotate(a) = rotate3D(0, 0, 1, a)</code>.</p>
<p>Здесь <code>x, y, z</code> — числа от нуля до одного, они описывают координату вектора, обозначающего ось вращения. <code>a</code> — угол поворота.</p>
<ul>
<li><code>scale3D(sx, sy, sz)</code>.</li>
</ul>
<p><code>scaleZ(sz) = scale3d(1, 1, sz)</code>.</p>
<p><code>sx, sy, sz</code> — числа, представляющие коэффициенты масштабирования по каждой оси.</p>
<ul>
<li><code>translate3D(tx, ty, tz)</code>.</li>
</ul>
<p><code>translateZ(tz) = translate3d(0, 0, tz)</code>.</p>
<p><code>tx, ty, tz</code> — числа, представляющие смещение по каждой оси.</p>
<figure>
<img src="../media/file86.png" alt="Оси элемента" />
<figcaption aria-hidden="true">Оси элемента</figcaption>
</figure>
</section>
<section id="backface-visibility" class="level3" data-number="5.4.3">
<h3 data-number="5.4.3">backface-visibility</h3>
<p>Не всегда при перевороте элемента нужно видеть его обратную сторону. Например, могут быть две стороны одной карточки. На второй стороне может быть другой текст, и тогда обратную сторону текста будем скрывать. Как раз для таких ситуаций есть свойство <code>backface-visibility</code>. Оно определяет, будет ли видна задняя сторона элемента, когда он повёрнут к пользователю.</p>
<p>Имеет значения:</p>
<ul>
<li><code>visible</code> — задняя сторона видна.</li>
<li><code>hidden</code> — задняя поверхность скрыта, что делает элемент невидимым, когда он повёрнут ею к пользователю.</li>
</ul>
<p>Прежде чем перейти к задаче с карточками, рассмотрим действие <code>backface-visibility</code> на очень простом примере — вращении кнопки при наведении. Это не совсем практичный пример, но он поможет подготовиться к следующей задаче с карточками. Воспользуемся дополнительной обёрткой <code>span</code>, которую мы будем анимировать. При наведении на кнопку станем поворачивать <code>span</code> на 180 градусов, чтобы увидеть его обратную часть.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">.btn</span> span {</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">transition</span>: transform <span class="dv">0.75</span><span class="dt">s</span> <span class="dv">ease</span><span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">transform</span>: rotateY(<span class="dv">0</span><span class="dt">deg</span>)<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="fu">.btn</span><span class="in">:hover</span> span {</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">transform</span>: rotateY(<span class="dv">180</span><span class="dt">deg</span>)<span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Для его родителя добавим <code>transform-style</code> и перспективу, чтобы видеть небольшой 3D-эффект поворота:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">.btn</span> {</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">transform-style</span>: preserve-3d<span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">perspective</span>: <span class="dv">1000</span><span class="dt">px</span><span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>А теперь посмотрите, как будет выглядеть разворот при разных значениях <code>backface-visibility</code>:</p>
<p><em>(см. 5.17. Демонстрация свойства backface-visibility)</em></p>
<p>Мы познакомились с основными свойствами, необходимыми для создания 3D-эффектов с помощью CSS. Теперь разберём несколько задач, которые они помогут решить.</p>
</section>
</div>
</section>
<section id="практическое-применение" class="level2" data-number="5.5">
<h2 data-number="5.5">5.5. Практическое применение</h2>
<div class="text-container text-container--module">
<p>Далее рассмотрим несколько примеров применения 3D-эффектов. И начнём с перемещения элементов в 3D-пространстве.</p>
<p>При изменении положения элемента по оси Z можно столкнуться с не самым приятным эффектом. Его размер будет меняться при отдалении или приближении к вьюпорту. Однако мы можем легко справиться с этой проблемой. Чтобы показывать элемент в реальном размере, следует применить к нему трансформацию <code>scale()</code>.</p>
<p>Для вычисления коэффициента масштабирования <code>scale</code> применяется следующая формула: <code>1 + (translateZ * -1) / perspective</code>.</p>
<p>То есть если свойство <code>perspective</code> равно 1px и мы передвигаем элемент по оси Z на -2px, то коэффициент будет равен трём:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">.layer</span> {</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">transform</span>: translateZ(<span class="dv">-2</span><span class="dt">px</span>) <span class="fu">scale(</span><span class="dv">3</span><span class="fu">)</span><span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Вспомним пример из прошлой статьи и немного доработаем:</p>
<p><em>(см. 5.18. Демонстрация компенсации размера элемента при размещении по оси Z)</em></p>
<p>Посмотрим пример применения этих свойств для эффекта 3D-поворота карточек:</p>
<p><em>(см. 5.19. Переворот карточки с 3D эффектом)</em></p>
<section id="скорость-движения" class="level3" data-number="5.5.1">
<h3 data-number="5.5.1">Скорость движения</h3>
<p>При смещении элементов по оси Z возникает интересный эффект — чем выше слой по оси Z, тем он быстрее движется, если его сместить по оси Х или У. А чем ниже, тем медленнее.</p>
<p>Разберём на примере демонстрации. Здесь полосы смещены по оси Z с шагом 50px, а при наведении каждый слой смещается на 50px по оси Х. Как видите, полосы движутся с разной скоростью.</p>
<p><em>(см. 5.20. Демонстрация разной скорости движения смещённых по оси Z элементов)</em></p>
<p>Воспользуемся этим для создания простой страницы с параллакс-эффектом шапки:</p>
<p><em>(см. 5.21. Параллакс шапки сайта)</em></p>
<p>Не стоит путать этот пример с другим, тоже популярным, но не имеющем никакого отношения к 3D и параллаксу. Здесь шапка использует фиксированное расположение фоновой картинки.</p>
<p><em>(см. 5.22. Пример шапки без параллакса)</em></p>
<p>А вот ещё одна реализация более эффектного первого экрана сайта</p>
<p><em>(см. 5.23. Многослойный параллакс шапки)</em></p>
<p>Таким образом, мы научились с помощью 3D-трансформаций добавлять параллакс-эффект за счёт CSS. Такое решение является максимально корректным с точки зрения производительности. Далее рассмотрим способы создания более сложного параллакса с помощью JavaScript.</p>
</section>
</div>
</section>
<section id="параллакс-эффект-на-чистом-css" class="level2" data-number="5.6">
<h2 data-number="5.6">5.6. <a href="https://htmlacademy.ru/blog/boost/tutorial/pure-css-parallax-websites">Параллакс-эффект на чистом CSS</a></h2>
</section>
<section id="задание-1-3" class="level2" data-number="5.7">
<h2 data-number="5.7">5.7. Задание 1</h2>
<div class="text-container text-container--module">
<p>3D-поворот карточек товара при наведении</p>
<p>Вам прислали вёрстку карточек каталога мебели. Необходимо добавить анимацию карточек при наведении таким образом, чтобы карточка разворачивалась на 180 градусов вдоль вертикали и показывала скрытое за ней описание. Разворот нужно сделать в 3D. Содержимое карточки тоже сделать трёхмерным, отодвинув по оси Z на 80px ближе к пользователю.</p>
</div>
</section>
<section id="эталонное-решение-задания-9" class="level2" data-number="5.8">
<h2 data-number="5.8">5.8. Эталонное решение задания</h2>
<div class="text-container text-container--module">
<section id="шаг-1-58" class="level3" data-number="5.8.1">
<h3 data-number="5.8.1">Шаг №1</h3>
<p>Пример эталонного решения.</p>
</section>
<section id="шаг-2-38" class="level3" data-number="5.8.2">
<h3 data-number="5.8.2">Шаг №2</h3>
<p>Сначала у нас видны обе части карточек и нет свойств для работы 3D. Добавим для <code>.product__wrap</code> <code>transform-style</code> и <code>perspective</code>.</p>
<p><code>position</code> потребуется, чтобы позиционировать заднюю часть карточки.</p>
</section>
<section id="шаг-3-38" class="level3" data-number="5.8.3">
<h3 data-number="5.8.3">Шаг №3</h3>
<p>Допишем карточкам <code>transform</code> в исходном положении и при наведении на <code>.product</code>. Поместим заднюю часть за переднюю.</p>
</section>
<section id="шаг-4-31" class="level3" data-number="5.8.4">
<h3 data-number="5.8.4">Шаг №4</h3>
<p>Добавляем смещение по оси Z для текста внутри карточки, смещая его на 80px к пользователю и скорректировав размер с помощью <code>scale</code>.</p>
<p>Готово!</p>
</section>
</div>
</section>
<section id="задание-2-3" class="level2" data-number="5.9">
<h2 data-number="5.9">5.9. Задание 2</h2>
<div class="text-container text-container--module">
<p>3D-шапка при прокрутке</p>
<p>В этот раз вам прислали на доработку простую страницу с примерами работ.</p>
<p>Задача: добавить блоку шапки параллакс-эффект при прокрутке страницы вниз.</p>
<p>Величина перспективы может быть равна 1px, шапка будет смещена по оси Z назад, а контент будет оставаться в плоскости Z=0.</p>
</div>
</section>
<section id="эталонное-решение-задания-10" class="level2" data-number="5.10">
<h2 data-number="5.10">5.10. Эталонное решение задания</h2>
<div class="text-container text-container--module">
<section id="шаг-1-59" class="level3" data-number="5.10.1">
<h3 data-number="5.10.1">Шаг №1</h3>
<p>Эталонное решение задания 2 модуля 5.</p>
</section>
<section id="шаг-2-39" class="level3" data-number="5.10.2">
<h3 data-number="5.10.2">Шаг №2</h3>
<p>В начале у нас есть вёрстка с обычной шапкой с фоновой картинкой без параллакс-эффекта.</p>
</section>
<section id="шаг-3-39" class="level3" data-number="5.10.3">
<h3 data-number="5.10.3">Шаг №3</h3>
<p>Скроем прокрутку у <code>body</code> и зададим <code>.wrap</code> свойства для 3D-трансформации вложенных в него элементов. Теперь полоса прокрутки страницы будет от элемента <code>wrap</code>, а не <code>body</code>.</p>
</section>
<section id="шаг-4-32" class="level3" data-number="5.10.4">
<h3 data-number="5.10.4">Шаг №4</h3>
<p>Теперь расположим фоновую картинку из псевдоэлемента <code>.header::after</code> на оси Z дальше от <code>.content</code>. А текст <code>.header__box</code> — выше. Слои будут смещаться относительно друг друга. Чтобы <code>.content</code> наезжал на шапку, задаём ему <code>transform: translateZ(0)</code>.</p>
<p>Готово!</p>
</section>
</div>
</section>
<section id="d-трансформации-с-помощью-javascript" class="level2" data-number="5.11">
<h2 data-number="5.11">5.11. 3D-трансформации с помощью JavaScript</h2>
<div class="text-container text-container--module">
<p>Мы познакомились с возможностями создания 3D-эффектов с помощью CSS. Теперь посмотрим, чем может быть полезен JavaScript. И в этом нам помогут уже известные вам события движения мыши <code>mousemove</code> и <code>mouseout</code>. С их помощью мы можем трансформировать элемент при движении мыши на нём. Рассмотрим пример с анимацией карточек товара.</p>
<section id="анимация-карточек-товара" class="level3" data-number="5.11.1">
<h3 data-number="5.11.1">Анимация карточек товара</h3>
<p>Сами карточки будут трансформироваться в 3D, поэтому для карточки укажем в стилях перспективу и возможность трёхмерных преобразований:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>perspective<span class="in">: 1000px;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>transform-style<span class="in">: preserve-3d</span>;</span></code></pre></div>
<p>Далее добавим обёртку, которая и будет трансформироваться за счёт изменения свойства <code>transform</code>. Чтобы это была анимация, не забываем описать переход:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>transition<span class="in">: transform</span> 0<span class="fu">.2s</span> ease<span class="op">,</span> box-shadow 0<span class="fu">.5s</span> ease-in-out;</span></code></pre></div>
<p>Нам потребуется некоторый коэффициент скорости (или ещё можно сказать «амплитуды») изменения значения трансформации. Назовём его <code>SPEED</code>. Чем больше это значение, тем быстрее будет расти угол поворота при перемещении мыши от центра к краям.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> SPEED <span class="op">=</span> <span class="fl">0.05</span><span class="op">;</span></span></code></pre></div>
<p>Для каждой карточки будем менять значения <code>transform: rotateX()</code> и <code>transform: rotateY()</code>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>box<span class="op">.</span><span class="fu">setAttribute</span>(<span class="st">&#39;style&#39;</span><span class="op">,</span> <span class="vs">`transform: rotateX(</span><span class="sc">${</span>a<span class="sc">}</span><span class="vs">deg) rotateY(</span><span class="sc">${</span>b<span class="sc">}</span><span class="vs">deg)`</span>)<span class="op">;</span></span></code></pre></div>
<p>Когда курсор будет расположен в центре карточки, значения <code>a/b</code> будут нулевыми. Чем дальше от центра находится курсор, тем больше угол поворота.</p>
<p>Значения положения курсора получим из методов события <code>evt.offsetY</code> и <code>evt.offsetX</code>. Размер карточки — с помощью методов элемента <code>offsetHeight</code> и <code>offsetWidth</code>.</p>
<p>Тогда угол поворота получим по следующим формулам:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> a <span class="op">=</span>  <span class="op">-</span> (evt<span class="op">.</span><span class="at">offsetY</span> <span class="op">-</span> box<span class="op">.</span><span class="at">offsetHeight</span> <span class="op">/</span> <span class="dv">2</span>) <span class="op">*</span> SPEED<span class="op">;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> b <span class="op">=</span> (evt<span class="op">.</span><span class="at">offsetX</span> <span class="op">-</span> box<span class="op">.</span><span class="at">offsetWidth</span> <span class="op">/</span> <span class="dv">2</span>) <span class="op">*</span> SPEED<span class="op">;</span></span></code></pre></div>
<p>Чтобы карточка возвращалась в исходное состояние, когда пользователь убрал с неё курсор, добавим обработчик события <code>mouseout</code>. В нём будем удалять атрибут <code>style</code> с трансформацией поворота.</p>
<p>В итоге получим такой код:</p>
<p><em>(см. 5.24. Анимация поворота карточек)</em></p>
</section>
<section id="анимация-главного-экрана" class="level3" data-number="5.11.2">
<h3 data-number="5.11.2">Анимация главного экрана</h3>
<p>Можем добавить несколько объектов, распределить их по оси Z и добавить каждому трансформацию. Объекты выше по оси Z будут двигаться быстрее, ниже — медленнее.</p>
<p>Рассмотрим главный экран с тремя элементами: фоновый с комнатой почти не двигается, средний элемент с рукой чуть быстрее, а верхний с телефоном — самый быстрый.</p>
<p>Для этого их родителю задаём переход и свойства для работы с 3D:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">.parallax__assets</span> {</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">transform-style</span>: preserve-3d<span class="op">;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">perspective</span>: <span class="dv">4000</span><span class="dt">px</span><span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">transition</span>: transform <span class="dv">0.3</span><span class="dt">s</span> <span class="dv">ease</span><span class="op">;</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Сами слои позиционируем поверх друг друга и указываем разные значения сдвига по оси Z:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">.parallax__layer--0</span> {</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">transform</span>: translateZ(<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="fu">.parallax__layer--1</span> {</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">transform</span>: translateZ(<span class="dv">300</span><span class="dt">px</span>)<span class="op">;</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="fu">.parallax__layer--2</span> {</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">transform</span>: translateZ(<span class="dv">600</span><span class="dt">px</span>)<span class="op">;</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Движение мыши у края области просмотра может привести к тому, что элементы будут сильно сдвигаться. В результате мы увидим край картинки — а это дефект. Такой момент нужно заранее обсуждать с дизайнером: возможно, он дорисует дополнительно картинку по краю. Если же добавить картинку не получается, то можно сделать элемент чуть больше, указав <code>scale</code>. Также можно сместить элемент выше или ниже, чтобы был некоторый запас.</p>
<p>В нашем случае сдвинем руку ниже, а фон немного увеличим. Тогда дефектов не будет.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">.parallax__layer--0</span> {</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">transform</span>: translateZ(<span class="dv">0</span>) <span class="fu">scale(</span><span class="dv">1.1</span><span class="fu">)</span><span class="op">;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="fu">.parallax__layer--1</span> {</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">transform</span>: translateZ(<span class="dv">300</span><span class="dt">px</span>) translateY(<span class="dv">5</span><span class="dt">%</span>)<span class="op">;</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Рассмотрим шаги решения задачи в демо ниже.</p>
<p><em>(см. 5.25. JS параллакс первого экрана)</em></p>
<p>В данных примерах мы использовали анимацию за счёт 3D-смещения, действующего на повороте. Такие анимации могут подойти не во всех случаях, и иногда деформации могут смотреться плохо. Вместо этого можно использовать, например, анимацию <code>perspective-origin</code>, как мы рассматривали ранее на примере с кубиком.</p>
</section>
</div>
</section>
<section id="задание-3-2" class="level2" data-number="5.12">
<h2 data-number="5.12">5.12. Задание 3</h2>
<div class="text-container text-container--module">
<p>3D-анимация первого экрана сайта.</p>
<p>В этом задании вам нужно сделать первый экран с многослойным параллакс-эффектом при движении мыши.</p>
<p>Используйте трансформацию поворота. Верхний слой сдвигается быстрее, нижний — медленнее. Используйте перспективу в 4000px. Смещайте слои параллакса с разницей в 150px по оси Z.</p>
<p>Чтобы при сдвиге не было видно краёв изображений, их масштаб должен быть чуть больше области просмотра. Тогда зазоры по краям не дадут им попасть в кадр. Более внимательно проверяйте результат при движении курсора у края области просмотра. Дом не должен парить над землёй.</p>
<p>Добейтесь адаптивного отображения параллакса до ширины вьюпорта 2000px. При необходимости допишите правила <code>@media</code>.</p>
</div>
</section>
<section id="эталонное-решение-задания-11" class="level2" data-number="5.13">
<h2 data-number="5.13">5.13. Эталонное решение задания</h2>
<div class="text-container text-container--module">
<section id="шаг-1-60" class="level3" data-number="5.13.1">
<h3 data-number="5.13.1">Шаг №1</h3>
<p>Эталонное решение. Далее пошагово рассмотрим его реализацию.</p>
</section>
<section id="шаг-2-40" class="level3" data-number="5.13.2">
<h3 data-number="5.13.2">Шаг №2</h3>
<p>Добавим стили для использования 3D-трансформаций и переход свойства <code>transform</code> для смягчения движения.</p>
<p>Сместим слои по оси Z, скорректировав масштаб. Слой с домом сдвинем немного ниже, чтобы при движении мыши не было видно разрыва между домом и землёй.</p>
</section>
<section id="шаг-3-40" class="level3" data-number="5.13.3">
<h3 data-number="5.13.3">Шаг №3</h3>
<p>Код JavaScript будет таким же, как и в демо из предыдущей главы. Параметр скорости подбираем «на глаз». Мы выбрали значение 0.005.</p>
</section>
<section id="шаг-4-33" class="level3" data-number="5.13.4">
<h3 data-number="5.13.4">Шаг №4</h3>
<p>Когда ширина окна уменьшается, элементы при движении мыши у края области просмотра должны выглядеть корректно. Проверяем это. Если нужно, корректируем с помощью <code>@media</code>.</p>
<p>Готово!</p>
</section>
</div>
</section>
<section id="тест-по-материалам-модуля-5" class="level2" data-number="5.14">
<h2 data-number="5.14">5.14. Тест по материалам модуля 5</h2>
<div class="text-container text-container--module">
<ol type="1">
<li><strong>В чём заключается идея параллакс-эффекта в вебе?</strong></li>
</ol>
<ul>
<li>Чем дальше от наблюдателя объект, тем медленнее он движется, а чем ближе — тем быстрее.</li>
<li>Чем ближе к наблюдателю объект, тем медленнее он движется, а чем дальше — тем быстрее.</li>
</ul>
<ol start="2" type="1">
<li><strong>Какое событие происходит, когда курсор движется внутри элемента или его дочерних элементов?</strong></li>
</ol>
<ul>
<li>mouseover.</li>
<li>mousemove.</li>
<li>mouseleave.</li>
</ul>
<ol start="3" type="1">
<li><strong>Нужно ли указывать transition для классического параллакса элементов за счёт JavaScript?</strong></li>
</ol>
<ul>
<li>Да.</li>
<li>Нет.</li>
</ul>
<ol start="4" type="1">
<li><strong>Какое свойство нужно обязательно указать для работы с трёхмерными трансформациями?</strong></li>
</ol>
<ul>
<li>transform-style со значением flat.</li>
<li>transform со значением translateZ(1px).</li>
<li>transform-style со значением preserve-3d.</li>
</ul>
<ol start="5" type="1">
<li><strong>Что такое perspective-origin?</strong></li>
</ol>
<ul>
<li>Перспектива.</li>
<li>Точка схождения перспективы.</li>
<li>Глубина перспективы.</li>
</ul>
<ol start="6" type="1">
<li><strong>Какой трансформации не существует в трёхмерном пространстве?</strong></li>
</ol>
<ul>
<li>scaleZ ().</li>
<li>rotateZ ().</li>
<li>skewZ().</li>
</ul>
<ol start="7" type="1">
<li><strong>Верно ли, что при указании rotateZ(angle) результат будет таким же, что и при rotate(angle)?</strong></li>
</ol>
<ul>
<li>Да.</li>
<li>Нет.</li>
<li>В зависимости от угла поворота.</li>
</ul>
<ol start="8" type="1">
<li><strong>За что отвечает свойство backface-visibility?</strong></li>
</ol>
<ul>
<li>За скрытие задней части элемента, когда он повёрнут ею к пользователю.</li>
<li>За отображение задней части элемента, когда он повёрнут к пользователю.</li>
<li>За определение, будет ли видна задняя сторона элемента, когда он повёрнут к пользователю.</li>
</ul>
<ol start="9" type="1">
<li><strong>Какой верный коэффициент масштабирования нужно задать для элемента, который был сдвинут по оси Z назад на 50px при значении перспективы 100px, чтобы его размер визуально не изменился?</strong></li>
</ol>
<ul>
<li>0.5.</li>
<li><ol type="1">
<li></li>
</ol></li>
<li>1.5.</li>
<li>2.</li>
</ul>
</div>
</section>
<section id="тест-по-материалам-модуля-5-ответы" class="level2" data-number="5.15">
<h2 data-number="5.15">5.14. Тест по материалам модуля 5 (Ответы)</h2>
<div class="text-container text-container--module">
<ol type="1">
<li><strong>В чём заключается идея параллакс-эффекта в вебе?</strong></li>
</ol>
<ul>
<li>Чем дальше от наблюдателя объект, тем медленнее он движется, а чем ближе — тем быстрее.</li>
</ul>
<ol start="2" type="1">
<li><strong>Какое событие происходит, когда курсор движется внутри элемента или его дочерних элементов?</strong></li>
</ol>
<ul>
<li>mousemove.</li>
</ul>
<ol start="3" type="1">
<li><strong>Нужно ли указывать transition для классического параллакса элементов за счёт JavaScript?</strong></li>
</ol>
<ul>
<li>Да.</li>
</ul>
<ol start="4" type="1">
<li><strong>Какое свойство нужно обязательно указать для работы с трёхмерными трансформациями?</strong></li>
</ol>
<ul>
<li>transform-style со значением preserve-3d.</li>
</ul>
<ol start="5" type="1">
<li><strong>Что такое perspective-origin?</strong></li>
</ol>
<ul>
<li>Точка схождения перспективы.</li>
</ul>
<ol start="6" type="1">
<li><strong>Какой трансформации не существует в трёхмерном пространстве?</strong></li>
</ol>
<ul>
<li>skewZ().</li>
</ul>
<ol start="7" type="1">
<li><strong>Верно ли, что при указании rotateZ(angle) результат будет таким же, что и при rotate(angle)?</strong></li>
</ol>
<ul>
<li>Да.</li>
</ul>
<ol start="8" type="1">
<li><strong>За что отвечает свойство backface-visibility?</strong></li>
</ol>
<ul>
<li>За определение, будет ли видна задняя сторона элемента, когда он повёрнут к пользователю.</li>
</ul>
<ol start="9" type="1">
<li><strong>Какой верный коэффициент масштабирования нужно задать для элемента, который был сдвинут по оси Z назад на 50px при значении перспективы 100px, чтобы его размер визуально не изменился?</strong></li>
</ol>
<ul>
<li>1.5.</li>
</ul>
</div>
</section>
<section id="демонстрация-изменения-точки-схождения-перспективы" class="level2" data-number="5.16">
<h2 data-number="5.16">5.15. Демонстрация изменения точки схождения перспективы</h2>
<section id="шаг-1-61" class="level3 text-container text-container--module" data-number="5.16.1">
<h3 data-number="5.16.1">Шаг №1</h3>
<p>Демонстрация изменения точки схождения перспективы.</p>
</section>
</section>
<section id="демонстрация-изменения-свойств-трансформации-по-оси-z" class="level2" data-number="5.17">
<h2 data-number="5.17">5.16. Демонстрация изменения свойств трансформации по оси Z</h2>
<div class="text-container text-container--module">
<section id="шаг-1-62" class="level3" data-number="5.17.1">
<h3 data-number="5.17.1">Шаг №1</h3>
<p>Демонстрация изменения свойств трансформации по оси Z. Изначальное положение картинки в плоскости <code>z = 0</code> представлено зелёным полупрозрачным блоком.</p>
<p>Пролистайте ниже, чтобы увидеть все три примера.</p>
<p><a href="https://picsum.photos/">Источник фото</a></p>
</section>
<section id="шаг-2-41" class="level3" data-number="5.17.2">
<h3 data-number="5.17.2">Шаг №2</h3>
<p>Для первого элемента добавлена анимация вращения вдоль оси Z.</p>
<p>Это то же самое, что и функция <code>rotate()</code>.</p>
</section>
<section id="шаг-3-41" class="level3" data-number="5.17.3">
<h3 data-number="5.17.3">Шаг №3</h3>
<p>Для второго элемента добавим трансформацию масштаба <code>scale</code> вдоль оси Z.</p>
<p>Так как точка трансформации находится в центре картинки, то её верхняя часть оказывается за слоем <code>z=0</code>, а нижняя часть — над. Изменение масштаба вдоль оси Z требует указания перспективы и небольшого поворота вдоль оси X.</p>
</section>
<section id="шаг-4-34" class="level3" data-number="5.17.4">
<h3 data-number="5.17.4">Шаг №4</h3>
<p>Для третьей картинки добавим анимацию, меняющую положение этой картинки вдоль оси Z. При смещении назад, оказываясь за исходным слоем, картинка уменьшается, при смещении вперёд — увеличивается.</p>
</section>
</div>
</section>
<section id="демонстрация-свойства-backface-visibility" class="level2" data-number="5.18">
<h2 data-number="5.18">5.17. Демонстрация свойства backface-visibility</h2>
<section id="шаг-1-63" class="level3 text-container text-container--module" data-number="5.18.1">
<h3 data-number="5.18.1">Шаг №1</h3>
<p>Демонстрация свойства <code>backface-visibility</code>.</p>
</section>
</section>
<section id="демонстрация-компенсации-размера-элемента-при-размещении-по-оси-z" class="level2" data-number="5.19">
<h2 data-number="5.19">5.18. Демонстрация компенсации размера элемента при размещении по оси Z</h2>
<div class="text-container text-container--module">
<section id="шаг-1-64" class="level3" data-number="5.19.1">
<h3 data-number="5.19.1">Шаг №1</h3>
<p>Изначальное положение картинки в плоскости <code>z = 0</code> представлено зелёным полупрозрачным блоком. Переместим картинку в плоскости Z на 50px назад. Картинка стала меньше.</p>
<p><a href="https://picsum.photos/">Источник фото</a></p>
</section>
<section id="шаг-2-42" class="level3" data-number="5.19.2">
<h3 data-number="5.19.2">Шаг №2</h3>
<p>Рассчитаем значение <code>scale</code>, чтобы сделать картинку исходного размера.</p>
</section>
<section id="шаг-3-42" class="level3" data-number="5.19.3">
<h3 data-number="5.19.3">Шаг №3</h3>
<p>Добавим немного магии и повернём всю нашу конструкцию. Мы увидим, что на самом деле картинка и зелёный слой лежат на расстоянии друг от друга.</p>
</section>
</div>
</section>
<section id="переворот-карточки-с-3d-эффектом" class="level2" data-number="5.20">
<h2 data-number="5.20">5.19. Переворот карточки с 3D эффектом</h2>
<div class="text-container text-container--module">
<section id="шаг-1-65" class="level3" data-number="5.20.1">
<h3 data-number="5.20.1">Шаг №1</h3>
<p>Переворот карточек с 3D-эффектом.</p>
<p><a href="https://picsum.photos/">Источник фото</a></p>
</section>
<section id="шаг-2-43" class="level3" data-number="5.20.2">
<h3 data-number="5.20.2">Шаг №2</h3>
<p>Чтобы создать такой эффект, в разметке карточки нужен контейнер-родитель <code>card__container</code> и две части карточки: передняя <code>card__front</code> и задняя <code>card__back</code>. Внутри каждой стороны карточки добавим обёртку <code>card__inner</code>, в которой будем хранить контент, и этот слой станем сдвигать по оси Z.</p>
</section>
<section id="шаг-3-43" class="level3" data-number="5.20.3">
<h3 data-number="5.20.3">Шаг №3</h3>
<p>Добавим для контейнера свойства, необходимые для работы 3D. Перспектива в 1000px, чтобы искажения при повороте были небольшими.</p>
<p>Передняя часть карточки изначально повёрнута к пользователю, задняя — развёрнута от него.</p>
<p>Не забываем о переходе для плавности поворота.</p>
</section>
<section id="шаг-4-35" class="level3" data-number="5.20.4">
<h3 data-number="5.20.4">Шаг №4</h3>
<p>Теперь позиционируем заднюю часть карточки за переднюю и добавим наведение, разворачивая обе части на 180 градусов. Скроем заднюю часть каждой карточки при развороте, чтобы не было искажений.</p>
<p>Отлично! Сама карточка поворачивается при наведении в 3D.</p>
</section>
<section id="шаг-5-26" class="level3" data-number="5.20.5">
<h3 data-number="5.20.5">Шаг №5</h3>
<p>Теперь сместим внутреннюю часть каждой карточки по оси Z от самой карточки на 60px ближе к пользователю, чтобы усилить 3D-эффект. Не забываем скорректировать масштаб.</p>
<p>Готово!</p>
</section>
</div>
</section>
<section id="демонстрация-разной-скорости-движения-смещённых-по-оси-z-элементов" class="level2" data-number="5.21">
<h2 data-number="5.21">5.20. Демонстрация разной скорости движения смещённых по оси Z элементов</h2>
<section id="шаг-1-66" class="level3 text-container text-container--module" data-number="5.21.1">
<h3 data-number="5.21.1">Шаг №1</h3>
<p>Демонстрация разной скорости движения элементов, смещённых по оси Z.</p>
</section>
</section>
<section id="параллакс-шапки-сайта" class="level2" data-number="5.22">
<h2 data-number="5.22">5.21. Параллакс шапки сайта</h2>
<div class="text-container text-container--module">
<section id="шаг-1-67" class="level3" data-number="5.22.1">
<h3 data-number="5.22.1">Шаг №1</h3>
<p>Параллакс шапки сайта при прокрутке страницы. Далее рассмотрим шаги его создания.</p>
<p>Слой <code>.content</code> смещается над <code>.header</code>. Внутри шапки текстовые слои находятся на отдельных слоях. Так создаётся глубина смещения.</p>
<p><a href="https://picsum.photos/">Источник фото</a></p>
</section>
<section id="шаг-2-44" class="level3" data-number="5.22.2">
<h3 data-number="5.22.2">Шаг №2</h3>
<p>Изначально текст позиционирован относительно шапки. В процессе работы свойства <code>top</code>, <code>botom</code>, <code>left</code>, <code>right</code> могут немного корректироваться, так как будет добавляться смещение с <code>transform</code>.</p>
<p>Фоновая картинка выносится в отдельный слой с псевлоэлементом. Позднее ему зададим смещение.</p>
</section>
<section id="шаг-3-44" class="level3" data-number="5.22.3">
<h3 data-number="5.22.3">Шаг №3</h3>
<p>Допишем перспективу и возможность трёхмерных манипуляций для <code>.wrap</code> и <code>.header</code>.</p>
</section>
<section id="шаг-4-36" class="level3" data-number="5.22.4">
<h3 data-number="5.22.4">Шаг №4</h3>
<p>Теперь вынесем шапку слоем ниже контента, скорректируем масштаб и положение шапки.</p>
<p>А в самой шапке сместим наверх слои с заголовком и подзаголовком. При этом тоже немного скорректируем их расположение.</p>
<p>Готово!</p>
</section>
</div>
</section>
<section id="пример-шапки-без-параллакса" class="level2" data-number="5.23">
<h2 data-number="5.23">5.22. Пример шапки без параллакса</h2>
<section id="шаг-1-68" class="level3 text-container text-container--module" data-number="5.23.1">
<h3 data-number="5.23.1">Шаг №1</h3>
<p>Шапка с фиксированным фоном.</p>
<p><a href="https://picsum.photos/">Источник фото</a></p>
</section>
</section>
<section id="многослойный-параллакс-шапки" class="level2" data-number="5.24">
<h2 data-number="5.24">5.23. Многослойный параллакс шапки</h2>
<div class="text-container text-container--module">
<section id="шаг-1-69" class="level3" data-number="5.24.1">
<h3 data-number="5.24.1">Шаг №1</h3>
<p>Параллакс занимает весь первый экран и состоит из шести слоёв <code>.parallax__layer</code> и контента под ними <code>.parallax__cover</code>.</p>
<p><a href="https://codepen.io/samdbeckham/pen/OPXPNp">Источник фото</a></p>
</section>
<section id="шаг-2-45" class="level3" data-number="5.24.2">
<h3 data-number="5.24.2">Шаг №2</h3>
<p>Изначально все слои позиционированы поверх друг друга, чтобы центр картинки был в центре экрана.</p>
<p>Графика готовится дизайнером заранее и имеет допуски на большие экраны, что видно по горизонтальной прокрутке. Позднее мы её скроем.</p>
</section>
<section id="шаг-3-45" class="level3" data-number="5.24.3">
<h3 data-number="5.24.3">Шаг №3</h3>
<p>Для родителя <code>.parallax</code> указываем необходимые свойства. Так как слоёв много, то значение перспективы берём хотя бы 100px. Этого будет достаточно, чтобы расположить шесть слоёв и показать разницу в скорости их движения.</p>
<p>Скрываем горизонтальную полосу прокрутки.</p>
</section>
<section id="шаг-4-37" class="level3" data-number="5.24.4">
<h3 data-number="5.24.4">Шаг №4</h3>
<p>Теперь распределяем слои с одинаковым шагом от самого дальнего до нуля, где находится <code>.parallax__cover</code>.</p>
<p>Не забываем скомпенсировать масштаб слоёв. Готово!</p>
</section>
</div>
</section>
<section id="анимация-поворота-карточек" class="level2" data-number="5.25">
<h2 data-number="5.25">5.24. Анимация поворота карточек</h2>
<div class="text-container text-container--module">
<section id="шаг-1-70" class="level3" data-number="5.25.1">
<h3 data-number="5.25.1">Шаг №1</h3>
<p>Анимация карточек при наведении мыши.</p>
<p>Далее подробно рассмотрим шаги её создания.</p>
<p><a href="https://picsum.photos/">Источник фото</a></p>
</section>
<section id="шаг-2-46" class="level3" data-number="5.25.2">
<h3 data-number="5.25.2">Шаг №2</h3>
<p>У нас есть несколько карточек с тенью, меняющейся при наведении. В стилях сразу укажем переход для трансформации и тени. Чуть позже с помощью JavaScript будем поворачивать карточку.</p>
<p>Так как карточки будут поворачиваться в трёхмерном пространстве, добавляем им необходимые свойства. Далее напишем скрипт.</p>
</section>
<section id="шаг-3-46" class="level3" data-number="5.25.3">
<h3 data-number="5.25.3">Шаг №3</h3>
<p>Сначала найдём карточки <code>items</code> и зададим параметр для интенсивности изменения трансформации <code>SPEED</code>.</p>
<p>Каждой карточке добавим слушатель события движения мыши <code>mousemove</code>. Будем вызывать <code>onCardMove</code>, которую опишем следующим шагом.</p>
</section>
<section id="шаг-4-38" class="level3" data-number="5.25.4">
<h3 data-number="5.25.4">Шаг №4</h3>
<p>В колбэк функции находим карточку <code>box</code>, на которой произошло событие. Рассчитываем углы поворота карточек и инлайново добавляем элементу трансформацию поворота по осям X и Y.</p>
<p>Отлично, карточки поворачиваются! Но когда мы отводим курсор с карточки, она остаётся трансформированной. Исправим это.</p>
</section>
<section id="шаг-5-27" class="level3" data-number="5.25.5">
<h3 data-number="5.25.5">Шаг №5</h3>
<p>Добавим карточкам слушатель события <code>mouseout</code>, то есть когда курсор ушёл с карточки. В этот момент будем удалять инлайновые стили, и таким образом карточка вернётся в исходное состояние. Так как на втором шаге мы указали <code>transition</code>, то анимации происходят плавно.</p>
<p>Готово, задача выполнена!</p>
</section>
</div>
</section>
<section id="js-параллакс-первого-экрана" class="level2" data-number="5.26">
<h2 data-number="5.26">5.25. JS параллакс первого экрана</h2>
<div class="text-container text-container--module">
<section id="шаг-1-71" class="level3" data-number="5.26.1">
<h3 data-number="5.26.1">Шаг №1</h3>
<p>JavaScript-параллакс первого экрана. Далее рассмотрим шаги его создания.</p>
<p><a href="https://picsum.photos/">Источник фото</a></p>
</section>
<section id="шаг-2-47" class="level3" data-number="5.26.2">
<h3 data-number="5.26.2">Шаг №2</h3>
<p>В разметке есть блок <code>parallax</code>, в котором будут происходить все манипуляции. Он занимает весь экран. Далее находится <code>parallax__assets</code> — родитель трансформируемых изображений с классом <code>parallax__layer</code>.</p>
</section>
<section id="шаг-3-47" class="level3" data-number="5.26.3">
<h3 data-number="5.26.3">Шаг №3</h3>
<p>Добавим <code>transform-style</code> и перспективу родителю. Не забудем о плавности изменения свойств, указав <code>transition</code>.</p>
<p>Расположим слои на оси Z. Пока что всё выглядит хорошо. Далее добавим JS-код для оживления анимации.</p>
</section>
<section id="шаг-4-39" class="level3" data-number="5.26.4">
<h3 data-number="5.26.4">Шаг №4</h3>
<p>Код будет тот же, что и в примере выше. Вращать будем <code>item</code>, меняя инлайново поворот на некоторое количество градусов.</p>
<p>Параметр <code>SPEED</code> отвечает за интенсивность смещения. Попробуйте сделать его немного больше, например, <code>0.03</code>. При этом и больших значениях мы видим дефекты: края картинок фона и руки. Доработаем это на новом шаге.</p>
</section>
<section id="шаг-5-28" class="level3" data-number="5.26.5">
<h3 data-number="5.26.5">Шаг №5</h3>
<p>Немного увеличим фон за счёт <code>scale</code>, а слой с рукой сдвинем ниже.</p>
<p>Теперь все корректно. Задача выполнена!</p>
</section>
</div>
</section>
<section id="d-параллакс-на-js" class="level2" data-number="5.27">
<h2 data-number="5.27">5.26. 2D параллакс на JS</h2>
<section id="шаг-1-72" class="level3 text-container text-container--module" data-number="5.27.1">
<h3 data-number="5.27.1">Шаг №1</h3>
<p>Результат статьи.</p>
</section>
</section>
</section>
</body>
</html>
