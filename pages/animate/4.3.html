<html lang="ru" class="">
<style>

</style>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" href="css/style_7.css">
  <link rel="stylesheet" href="css/style_1.css">
  <script>
    document.documentElement.classList.remove('no-js');
  </script>
  <script src="js/js_1.js" data-sentry="ff96f5d0a0ad4071ac8e8c7b3302d90d" data-project="13"></script>
  <link rel="stylesheet" href="css/style_2.css">
  <link rel="stylesheet" href="css/style_3.css">
  <link rel="stylesheet" href="css/style_4.css">
  <link rel="stylesheet" href="css/style_5.css">
  <link rel="stylesheet" href="css/style_8.css"><link rel="shortcut icon" type="image/x-icon" href="https://up.htmlacademy.ru/meta/animation-favicon.ico">

  <meta name="theme-color" content="#2e368e">
  <meta name="application-name" content="Анимация для фронтендеров #1">
  <meta name="apple-mobile-web-app-title" content="Анимация для фронтендеров #1">
  <link rel="preload" href="css/2DF5B4_F_0.woff2" type="font/woff2" as="font" crossorigin="anonymous">
  <link rel="preload" href="css/2DF5B4_D_0.woff2" type="font/woff2" as="font" crossorigin="anonymous">
  <link rel="preload" href="css/2DF5B4_2_0.woff2" type="font/woff2" as="font" crossorigin="anonymous">
  <link rel="preload" href="css/ubuntu-mono.woff2" type="font/woff2" as="font" crossorigin="anonymous">
  <link rel="preload" href="css/style_6.css">
  <style>
    .side-menu--php .side-menu__item {
      color: #fff;
    }
  </style>
  <script>
    (function (w, d, s, l, i) {
      w[l] = w[l] || [];
      w[l].push({
        'gtm.start': new Date().getTime(),
        event: 'gtm.js'
      });
      var f = d.getElementsByTagName(s)[0],
        j = d.createElement(s),
        dl = l != 'dataLayer' ? '&l=' + l : '';
      j.async = true;
      j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl;
      f.parentNode.insertBefore(j, f);
    })(window, document, 'script', 'dataLayer', 'GTM-W3ZS73J');
  </script>
  <style type="text/css">
    .hljs {
      display: block;
      color: black;
    }

    .hljs-built_in,
    .hljs-keyword,
    .hljs-builtin-name,
    .hljs-selector-id {
      color: blue;
    }

    .hljs-subst,
    .hljs-attr {
      color: black;
    }

    .hljs-title,
    .hljs-type {
      color: #0000A2;
    }

    .hljs-literal {
      color: rgb(88, 92, 246);
    }

    .hljs-number {
      color: rgb(0, 0, 205);
    }

    .hljs-regexp,
    .hljs-string,
    .hljs-doctag,
    .hljs-selector-pseudo {
      color: rgb(3, 106, 7);
    }

    .hljs-selector-class,
    .hljs-variable {
      color: rgb(49, 132, 149);
    }

    .hljs-selector-tag {
      color: rgb(197, 6, 11);
    }

    .hljs-attribute {
      color: rgb(109, 121, 222);
    }

    .hljs-comment,
    .hljs-quote {
      color: rgb(76, 136, 107);
    }

    .hljs-meta {
      color: rgb(104, 104, 91);
    }

    .hljs-tag {
      color: rgb(0, 22, 142);
    }
  </style>
</head>

<body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-W3ZS73J" height="0" width="0"
      style="display:none;visibility:hidden"></iframe></noscript>
  <div class="page-content page-content--relative page-content--php page-content--up">
    <div class="blog-section blog-section--page blog-section--black-white">
      <div class="blog-section__wrap">
        <div class="side-menu__wrap">
          <div class="side-menu side-menu--main side-menu--php side-menu--up">
            <div class="side-menu__title"><a class="side-menu__link side-menu__link--main link"
                href="index.html">Учебник</a><button class="side-menu__button" type="button"><span
                  class="sr-only">Развернуть /
                  Свернуть</span><svg aria-hidden="true" width="8" height="16">
                  <use xlink:href="img/sprites/up.svg?cs=fb70597153879c70ce140224310b7444b664990a#icon-arrow-right">
                  </use>
                </svg></button></div>
            <ul class="side-menu__list"><li class="side-menu__item"><button class="side-menu__toggle"
                          type="button"><span class="sr-only">Развернуть /
                              Свернуть</span></button>0.&nbsp;Проект + задания
                          <ul class="side-menu__inner-list">
                              <li class="side-menu__inner-item ">
                                    <a href="0.1.html">0.1.&nbsp;Критерии</a>
                              </li>
                              <li class="side-menu__inner-item"><a href="0.2.html">0.2.&nbsp;ТЗ + файлы проекта</a></li>
                              <li class="side-menu__inner-item"><a href="0.3.html">0.3.&nbsp;Задания к главам учебника</a></li>
                
                          </ul>
                    </li>
              <li class="side-menu__item"><button class="side-menu__toggle" type="button"><span
                    class="sr-only">Развернуть /
                    Свернуть</span></button>1.&nbsp;Основы
                анимации
                <ul class="side-menu__inner-list">
                  <li class="side-menu__inner-item ">
                    <a href="1.1.html">1.1.&nbsp;Вступление</a>
                  </li>
                  <li class="side-menu__inner-item"><a href="1.2.html">1.2.&nbsp;История
                      анимации</a></li>
                  <li class="side-menu__inner-item"><a href="1.3.html">1.3.&nbsp;Физиология
                      восприятия анимации.
                      Понятие FPS.</a></li>
                  <li class="side-menu__inner-item"><a href="1.4.html">1.4.&nbsp;Кривая
                      Безье в CSS</a></li>
                  <li class="side-menu__inner-item"><a href="1.5.html">1.5.&nbsp;Линейные
                      и Покадровые анимации</a></li>
                  <li class="side-menu__inner-item"><a href="1.6.html">1.6.&nbsp;CSS
                      Transition</a></li>
                  <li class="side-menu__inner-item"><a href="1.7.html">1.7.&nbsp;С
                      чего
                      начать делать анимацию</a></li>
                </ul>
              </li>
              <li class="side-menu__item"><button class="side-menu__toggle" type="button"><span
                    class="sr-only">Развернуть /
                    Свернуть</span></button>2.&nbsp;Анимация
                в CSS
                <ul class="side-menu__inner-list">
                  <li class="side-menu__inner-item"><a href="2.1.html">2.1.&nbsp;Директива
                      @keyframes и группа
                      свойств
                      Animation CSS</a></li>
                  <li class="side-menu__inner-item"><a href="2.2.html">2.2.&nbsp;Отслеживания
                      изменений в CSS.
                      Процесс
                      перерисовки страницы.</a></li>
                  <li class="side-menu__inner-item"><a href="2.3.html">2.3.&nbsp;Инструменты
                      для отладки анимации
                      и
                      производительности анимации</a>
                  </li>
                  <li class="side-menu__inner-item"><a href="2.4.html">2.4.&nbsp;Производительность.
                      CSS анимация
                      на
                      GPU</a></li>
                  <li class="side-menu__inner-item"><a href="2.5.html">2.5.&nbsp;Побуквеная
                      анимация текста</a>
                  </li>
                  <li class="side-menu__inner-item"><a href="2.6.html">2.6.&nbsp;Медиазапросы
                      prefers-reduced-motion и
                      update</a></li>
                </ul>
              </li>
              <li class="side-menu__item"><button class="side-menu__toggle" type="button"><span
                    class="sr-only">Развернуть /
                    Свернуть</span></button>3.&nbsp;SVG
                Анимация
                <ul class="side-menu__inner-list">
                  <li class="side-menu__inner-item"><a href="3.1.html">3.1.&nbsp;Вступление</a>
                  </li>
                  <li class="side-menu__inner-item
     ">
                    <span>3.2.&nbsp;Тег
                    &lt;animate&gt;</span>
                    <ul class="side-menu__inner-list side-menu__inner-list--second" style="display:block">
                      <li class="side-menu__inner-item  ">
                        <a href="3.2.1.html">3.2.1.&nbsp;Передача
                          параметров
                          и
                          время
                          проигрывания</a>
                      </li>
                      <li class="side-menu__inner-item ">
                        <a href="3.2.2.html">3.2.2.&nbsp;Интерактивность
                          анимаций</a>
                      </li>
                      <li class="side-menu__inner-item ">
                        <a href="3.2.3.html">3.2.3.&nbsp;Функции
                          времени</a>
                      </li>
                      <li class="side-menu__inner-item ">
                        <a href="3.2.4.html">3.2.4.&nbsp;Морфинг
                          контура</a>
                      </li>
                    </ul>
                  </li>
                  <li class="side-menu__inner-item"><a href="3.3.html">3.3.&nbsp;Тег
                      &lt;set&gt;</a></li>
                  <li class="side-menu__inner-item"><a href="3.4.html">3.4.&nbsp;Тег
                      &lt;animateTransform&gt;</a>
                  </li>
                  <li class="side-menu__inner-item"><a href="3.5.html">3.5.&nbsp;Тег
                      &lt;animateMotion&gt;</a></li>
                  <li class="side-menu__inner-item"><a href="3.6.html">3.6.&nbsp;Методика
                      реализации SMIL анимации</a>
                  </li>
                  <li class="side-menu__inner-item"><a href="3.7.html">3.7.&nbsp;Отрисовка
                      объектов внутри
                      SVG</a>
                  </li>
                  <li class="side-menu__inner-item"><a href="3.8.html">3.8.&nbsp;Инструкция
                      по работе с
                      программой
                      Adobe After Effects</a></li>
                  <li class="side-menu__inner-item"><a href="3.9.html">3.9.&nbsp;Ритм
                      анимации</a></li>
                  <li class="side-menu__inner-item"><a href="3.10.html">3.10.&nbsp;Методы
                      описания кривых траекторий</a>
                  </li>
                </ul>
              </li>
              <li class="side-menu__item"><button class="side-menu__toggle" type="button"><span
                    class="sr-only">Развернуть /
                    Свернуть</span></button>4.&nbsp;Покадровая
                анимация. JavaScript и Canvas
                <ul class="side-menu__inner-list">
                  <li class="side-menu__inner-item"><a href="4.1.html">4.1.&nbsp;Покадровая
                      анимация</a></li>
                  <li class="side-menu__inner-item"><a href="4.2.html">4.2.&nbsp;Временные
                      функции</a></li>
                  <li class="side-menu__inner-item"><a href="4.3.html">4.3.&nbsp;Рисование
                      в canvas</a></li>
                  <li class="side-menu__inner-item"><a href="4.4.html">4.4.&nbsp;Анимация
                      в canvas</a></li>
                  <li class="side-menu__inner-item"><a href="4.5.html">4.5.&nbsp;Методика
                      реализации canvas анимации</a>
                  </li>
                </ul>
              </li>
              <li class="side-menu__item"><button class="side-menu__toggle" type="button"><span
                    class="sr-only">Развернуть /
                    Свернуть</span></button>5.&nbsp;WebGL.
                Шейдеры</a>
                <ul class="side-menu__inner-list">
                  <li class="side-menu__inner-item"><a href="5.1.html">5.1.&nbsp;Использование
                      GPU для отрисовки
                      сложной графики</a></li>
                  <li class="side-menu__inner-item"><a href="5.2.html">5.2.&nbsp;Использование
                      WebGL</a></li>
                  <li class="side-menu__inner-item"><a href="5.3.html">5.3.&nbsp;Библиотеки
                      WebGL</a></li>
                  <li class="side-menu__inner-item"><a href="5.4.html">5.4.&nbsp;План
                      изучения WebGL</a></li>
                  <li class="side-menu__inner-item"><a href="5.5.html">5.5.&nbsp;3D-объекты
                      в WebGL</a></li>
                  <li class="side-menu__inner-item"><a href="5.6.html">5.6.&nbsp;WebGL
                      pipeline. Вершинный и
                      фрагментный шейдеры</a></li>
                  <li class="side-menu__inner-item"><a href="5.7.html">5.7.&nbsp;Подготовка
                      и запуск программы
                      WebGL в
                      JS</a></li>
                  <li class="side-menu__inner-item"><a href="5.8.html">5.8.&nbsp;Синтаксис
                      GLSL</a></li>
                  <li class="side-menu__inner-item"><a href="5.9.html">5.9.&nbsp;Типы
                      данных в WebGL</a></li>
                  <li class="side-menu__inner-item"><a href="5.10.html">5.10.&nbsp;Функции
                      в WebGL</a></li>
                  <li class="side-menu__inner-item"><a href="5.11.html">5.11.&nbsp;Функция
                      шейдера main()</a>
                  </li>
                  <li class="side-menu__inner-item"><a href="5.12.html">5.12.&nbsp;Приём
                      данных в GLSL из JS</a></li>
                  <li class="side-menu__inner-item"><a href="5.13.html">5.13.&nbsp;Передача
                      данных из вершинного
                      шейдера в фрагментный шейдер</a>
                  </li>
                  <li class="side-menu__inner-item"><a href="5.14.html">5.14.&nbsp;Отладка
                      программы WebGL</a>
                  </li>
                  <li class="side-menu__inner-item"><a href="5.15.html">5.15.&nbsp;Three.JS.
                      Вступление</a></li>
                  <li class="side-menu__inner-item"><a href="5.16.html">5.16.&nbsp;Инфраструктура
                      Three.JS для
                      рендеринга 3D изображений</a>
                  </li>
                  <li class="side-menu__inner-item"><a href="5.17.html">5.17.&nbsp;Геометрия
                      и материал
                      визуального
                      объекта в Three.JS</a></li>
                  <li class="side-menu__inner-item"><a href="5.18.html">5.18.&nbsp;Материалы
                      ShaderMaterial и
                      RawShaderMaterial</a></li>
                  <li class="side-menu__inner-item"><a href="5.19.html">5.19.&nbsp;Цвет
                      как вектор</a></li>
                  <li class="side-menu__inner-item"><a href="5.20.html">5.20.&nbsp;Цветовые
                      фильтры и матрица
                      преобразования</a></li>
                  <li class="side-menu__inner-item"><a href="5.21.html">5.21.&nbsp;Blending.
                      Наложение двух
                      изображений</a></li>
                  <li class="side-menu__inner-item"><a href="5.22.html">5.22.&nbsp;Работа
                      с alpha-каналом и маскирование
                      изображений</a></li>
                  <li class="side-menu__inner-item"><a href="5.23.html">5.23.&nbsp;Шум</a>
                  </li>
                  <li class="side-menu__inner-item"><a href="5.24.html">5.24.&nbsp;Displacement
                      по карте
                      смещений</a>
                  </li>
                  <li class="side-menu__inner-item"><a href="5.25.html">5.25.&nbsp;Покадровая
                      анимация параметров
                      кастомного материала в JS</a>
                  </li>
                  <li class="side-menu__inner-item"><a href="5.26.html">5.26.&nbsp;Расчётная
                      анимация в шейдерах
                      и
                      параметр времени</a></li>
                </ul>
              </li>
              <li class="side-menu__item"><button class="side-menu__toggle" type="button"><span
                    class="sr-only">Развернуть /
                    Свернуть</span></button>6.&nbsp;Three.js
                часть 1: 3D в браузере
                <ul class="side-menu__inner-list">
                  <li class="side-menu__inner-item"><a href="6.1.html">6.1.&nbsp;Работа
                      с
                      3D в Three.js. Введение</a></li>
                  <li class="side-menu__inner-item"><a href="6.2.html">6.2.&nbsp;3D-объект
                      в Three.js</a></li>
                  <li class="side-menu__inner-item"><a href="6.3.html">6.3.&nbsp;Схема
                      3D-приложения Three.js с одним
                      объектом</a></li>
                  <li class="side-menu__inner-item"><a href="6.4.html">6.4.&nbsp;Схема
                      3D-приложения Three.js и процесс
                      рендеринга Scene</a></li>
                  <li class="side-menu__inner-item"><a href="6.5.html">6.5.&nbsp;Источники
                      света</a></li>
                  <li class="side-menu__inner-item"><a href="6.6.html">6.6.&nbsp;Родительский
                      класс объектов
                      Object3D</a></li>
                  <li class="side-menu__inner-item"><a href="6.7.html">6.7.&nbsp;Основные
                      объекты Mesh, Points, Line,
                      LineLoop, LineSegments</a></li>
                  <li class="side-menu__inner-item"><a href="6.8.html">6.8.&nbsp;Группирование
                      объектов в
                      Group</a>
                  </li>
                  <li class="side-menu__inner-item"><a href="6.9.html">6.9.&nbsp;Описание
                      геометрии в BufferGeometry и
                      DirectGeometry</a></li>
                  <li class="side-menu__inner-item"><a href="6.10.html">6.10.&nbsp;Параметрические
                      геометрии
                      Three.js</a></li>
                  <li class="side-menu__inner-item"><a href="6.11.html">6.11.&nbsp;Shape
                      и 3D-геометрии на их базе:
                      ShapeGeometry,
                      ExtrudeGeometry</a></li>
                  <li class="side-menu__inner-item"><a href="6.12.html">6.12.&nbsp;Фигуры
                      вращение с помощью
                      LatheGeometry</a></li>
                  <li class="side-menu__inner-item"><a href="6.13.html">6.13.&nbsp;Подготовка
                      геометрии для
                      Points,
                      Line, LineLoop, LineSegments</a>
                  </li>
                  <li class="side-menu__inner-item"><a href="6.14.html">6.14.&nbsp;Материалы
                      объектов Mesh</a>
                  </li>
                  <li class="side-menu__inner-item"><a href="6.15.html">6.15.&nbsp;Тени
                      в
                      Three.js</a></li>
                  <li class="side-menu__inner-item"><a href="6.16.html">6.16.&nbsp;Прозрачность
                      и Blending</a>
                  </li>
                  <li class="side-menu__inner-item"><a href="6.17.html">6.17.&nbsp;Материал
                      MeshMatcapMaterial</a>
                  </li>
                  <li class="side-menu__inner-item"><a href="6.18.html">6.18.&nbsp;Материал
                      PointsMaterial</a>
                  </li>
                  <li class="side-menu__inner-item"><a href="6.19.html">6.19.&nbsp;Загрузка
                      3D-моделей</a></li>
                  <li class="side-menu__inner-item"><a href="6.20.html">6.20.&nbsp;Загрузка
                      3D-объектов в формате
                      gLTF</a></li>
                  <li class="side-menu__inner-item"><a href="6.21.html">6.21.&nbsp;Анимация
                      3D-объектов.
                      Введение</a>
                  </li>
                  <li class="side-menu__inner-item"><a href="6.22.html">6.22.&nbsp;Анимация
                      Object3D</a></li>
                  <li class="side-menu__inner-item"><a href="6.23.html">6.23.&nbsp;Изоляция
                      движения с помощью
                      Group</a></li>
                  <li class="side-menu__inner-item"><a href="6.24.html">6.24.&nbsp;Способы
                      анимации формы
                      объекта</a>
                  </li>
                </ul>
              </li>
              <li class="side-menu__item"><button class="side-menu__toggle" type="button"><span
                    class="sr-only">Развернуть /
                    Свернуть</span></button>7.&nbsp;Three.js
                часть 2. Работа с камерой и
                финализация
                работы с 3D
                <ul class="side-menu__inner-list">
                  <li class="side-menu__inner-item"><a href="7.1.html">7.1.&nbsp;Ещё
                      раз
                      об изоляции движения</a></li>
                  <li class="side-menu__inner-item"><a href="7.2.html">7.2.&nbsp;Понятие
                      Rig</a></li>
                  <li class="side-menu__inner-item"><a href="7.3.html">7.3.&nbsp;Методика
                      структурного Rigging</a></li>
                  <li class="side-menu__inner-item"><a href="7.4.html">7.4.&nbsp;Класс
                      Camera в Three.js</a></li>
                  <li class="side-menu__inner-item"><a href="7.5.html">7.5.&nbsp;Типы
                      Camera и их настройка</a></li>
                  <li class="side-menu__inner-item"><a href="7.6.html">7.6.&nbsp;Переключение
                      между камерами</a>
                  </li>
                  <li class="side-menu__inner-item"><a href="7.7.html">7.7.&nbsp;Виды
                      склеек кадров</a></li>
                  <li class="side-menu__inner-item"><a href="7.8.html">7.8.&nbsp;Правила
                      и приёмы монтажа</a></li>
                  <li class="side-menu__inner-item"><a href="7.9.html">7.9.&nbsp;Множественный
                      рендеринг и
                      мультиэкраны</a></li>
                  <li class="side-menu__inner-item"><a href="7.10.html">7.10.&nbsp;Внутрикадровый
                      монтаж</a></li>
                  <li class="side-menu__inner-item"><a href="7.11.html">7.11.&nbsp;Конструкции
                      Camera Rig:
                      1-node,
                      2-nodes и 1-node с "нулём"</a>
                  </li>
                  <li class="side-menu__inner-item"><a href="7.12.html">7.12.&nbsp;Конструкции
                      Camera Rig: Долли
                      и
                      кран</a></li>
                  <li class="side-menu__inner-item"><a href="7.13.html">7.13.&nbsp;Конструкция
                      Camera Rig
                      свободного
                      облёта</a></li>
                  <li class="side-menu__inner-item"><a href="7.14.html">7.14.&nbsp;Разработка
                      конструкции Camera
                      Rig
                      под задачу</a></li>
                  <li class="side-menu__inner-item"><a href="7.15.html">7.15.&nbsp;Дополнительные
                      действия с
                      объектами
                      при перемещении камеры</a></li>
                  <li class="side-menu__inner-item"><a href="7.16.html">7.16.&nbsp;Реакция
                      камеры на действия
                      пользователя</a></li>
                  <li class="side-menu__inner-item"><a href="7.17.html">7.17.&nbsp;Resize-кадрирование
                      3D-сцены
                      при
                      изменении размеров экрана</a>
                  </li>
                  <li class="side-menu__inner-item"><a href="7.18.html">7.18.&nbsp;Способы
                      оптимизации 3D-сцены
                      под
                      мобильные устройства</a></li>
                  <li class="side-menu__inner-item"><a href="7.19.html">7.19.&nbsp;Предварительная
                      загрузка
                      материалов</a></li>
                  <li class="side-menu__inner-item"><a href="7.20.html">7.20.&nbsp;Использование
                      EffectComposer</a>
                  </li>
                </ul>
              </li>
              <li class="side-menu__item"><button class="side-menu__toggle" type="button"><span
                    class="sr-only">Развернуть /
                    Свернуть</span></button>8.&nbsp;Будущее
                анимации в браузере
                <ul class="side-menu__inner-list">
                  <li class="side-menu__inner-item"><a href="8.1.html">8.1.&nbsp;Web
                      Animation API</a></li>
                  <li class="side-menu__inner-item"><a href="8.2.html">8.2.&nbsp;CSS
                      Houdini</a></li>
                  <li class="side-menu__inner-item"><a href="8.3.html">8.3.&nbsp;Библиотеки
                      и инструменты для
                      упрощения работы с анимациями,
                      таймлайнами, SVG, canvas,
                      WebGL.</a></li>
                  <li class="side-menu__inner-item"><a href="8.4.html">8.4.&nbsp;GSAP</a>
                  </li>
                  <li class="side-menu__inner-item"><a href="8.5.html">8.5.&nbsp;Графические
                      редакторы анимации
                      для
                      использования в web</a></li>
                  <li class="side-menu__inner-item"><a href="8.6.html">8.6.&nbsp;Платформы
                      Unity3d и Unreal
                      Engine</a>
                  </li>
                </ul>
              </li>
            </ul>
          </div>
        </div>

        <div class="blog-section__content">
          <div class="blog-section__wrap-inner">
            <div class="post-info post-info--up">
              <p class="post-info__head"><span class="post-info__type">Базовая
                  теория</span></p>
              <h2 class="post-info__title">Глава 4.3.&nbsp;Рисование в canvas
              </h2>
            </div>
            <div class="post-content">
              <p>При использовании JavaScript-анимации можно изменять
                и&nbsp;дополнять контент DOM-структуры документа.
                Но&nbsp;сам HTML изначально не&nbsp;создавался для
                анимации, он&nbsp;рассчитан на&nbsp;статическое
                отображение информации. Для сложных анимаций и&nbsp;сцен
                с&nbsp;большим количеством объектов используют
                технологию <strong>canvas</strong>.</p>
              <p><strong>Canvas</strong>&nbsp;— это элемент HTML5, который
                предназначен для создания растрового
                изображения с&nbsp;помощью JavaScript.</p>
              <pre><code class="html language-html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"demo"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span>
</code></pre>
              <p>Элемент <code>&lt;canvas&gt;</code> имеет только два
                атрибута: ширину (<strong>width</strong>)
                и&nbsp;высоту (<strong>height</strong>), но&nbsp;они
                необязательны и&nbsp;могут быть выставлены
                с&nbsp;использованием свойств&nbsp;DOM. Если атрибуты
                не&nbsp;установлены, по&nbsp;умолчанию ширина
                canvas будет 300 px, а&nbsp;высота&nbsp;— 150&nbsp;px.
                Можно задать произвольные размеры в&nbsp;CSS,
                но&nbsp;во&nbsp;время рендеринга изображение будет
                масштабироваться в&nbsp;соответствии с&nbsp;его
                размером и&nbsp;ориентацией.</p>
              <h2><strong>Рендеринг содержимого (контекста)</strong></h2>
              <p>Элемент <strong>canvas</strong> создаётся
                с&nbsp;фиксированным размером элемента для рисования,
                который
                может иметь один или несколько контекстов для
                рендеринга, создавая содержимое и&nbsp;манипулируя
                им&nbsp;для показа.</p>
              <p>Холст изначально пустой и&nbsp;прозрачный. Для рисования
                прежде всего нужно получить доступ
                к&nbsp;контексту, на&nbsp;котором будет выполняться
                отрисовка объектов. Для этого
                <strong>canvas</strong> имеет метод <strong>getContext
                  ()</strong>, он&nbsp;принимает единственный
                параметр&nbsp;— один из&nbsp;типов контекста:</p>
              <ul>
                <li><strong>2d</strong> (стандартно)&nbsp;— двухмерный
                  контекст;</li>
                <li><strong>webgl</strong> использует 3D-контекст,
                  который реализуют WebGL первой версии (OpenGL
                  ES&nbsp;2.0);</li>
                <li><strong>webgl2</strong> использует 3D-контекст WebGL
                  второй версии (OpenGL ES&nbsp;3.0).</li>
              </ul>
              <p>Для 2D графики в&nbsp;этом разделе будем использовать метку
                <strong>2d</strong>.</p>
              <h2>Рисование фигур</h2>
              <p>Теперь, установив окружение, можно погрузиться в&nbsp;детали
                того, как рисовать объекты
                в&nbsp;<strong>canvas</strong>.</p>
              <h3>Прямоугольник</h3>
              <p>В&nbsp;отличие от&nbsp;SVG, <strong>canvas</strong>
                поддерживает только одну примитивную фигуру:
                прямоугольник. Все другие фигуры создаются комбинацией
                одного или большего количества контуров
                (<strong>paths</strong>)&nbsp;— набором точек,
                соединённых в&nbsp;линии. Это не&nbsp;страшно,
                в&nbsp;ассортименте рисования контуров есть функции,
                с&nbsp;помощью которых можно составлять очень
                сложные фигуры.</p>
              <p>Вот две функции рисования прямоугольников
                в&nbsp;<strong>canvas</strong>:</p>
              <ul>
                <li><code>fillRect(x, y, width, height)</code>&nbsp;—
                  заполненный прямоугольник;</li>
                <li><code>strokeRect(x, y, width, height)</code>&nbsp;—
                  прямоугольный контур.</li>
              </ul>
              <p>Каждая из&nbsp;этих функций принимает несколько параметров:
              </p>
              <ul>
                <li><strong>x</strong>, <strong>y</strong> устанавливают
                  положение верхнего левого угла прямоугольника
                  относительно начала координат;</li>
                <li><strong>width</strong>
                  и&nbsp;<strong>height</strong> определяют
                  размеры прямоугольника.</li>
              </ul>
              <pre><code class="js language-js hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">draw</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'canvas'</span>);
  <span class="hljs-keyword">if</span> (canvas.getContext) {
    <span class="hljs-keyword">let</span> ctx = canvas.getContext(<span class="hljs-string">'2d'</span>);

    ctx.fillRect(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>);
    ctx.strokeRect(<span class="hljs-number">100</span>, <span class="hljs-number">20</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>);
  }
}
</code></pre>
              <p>Пример:</p>
              <p><img src="images/rects-canvas.png" alt="rects-canvas"></p>
              <h3>Контуры (path)</h3>
              <p>Остальные примитивные фигуры создаются контурами.
                Контур&nbsp;— это точки, которые соединяются
                в&nbsp;отрезки линий и&nbsp;образуют различные фигуры:
                изогнутые или нет, разной ширины, высоты или
                цвета. Контур (или субконтур) может быть закрытым.</p>
              <p>Создание фигур с&nbsp;помощью контуров происходит
                в&nbsp;несколько шагов:</p>
              <ol>
                <li>Создать контур.</li>
                <li>Нарисовать нужную фигуру, используя команды
                  рисования.</li>
                <li>Закрыть контур.</li>
                <li>Обвести или залить созданный контур для его
                  отображения.</li>
              </ol>
              <p>Первый шаг создания контура заключается в&nbsp;вызове функции
                <strong>beginPath ()</strong>. Внутри
                содержатся контуры в&nbsp;виде набора субконтуров
                (линии, дуги и&nbsp;др.), которые вместе образуют
                фигуру. Каждый вызов этого метода очищает набор,
                и&nbsp;можно рисовать уже новые фигуры.</p>
              <p>Второй шаг&nbsp;— вызов методов, определяемых видом контура,
                который нужно нарисовать. Их&nbsp;рассмотрим
                позднее.</p>
              <p>Третий и&nbsp;необязательный шаг&nbsp;— вызов
                <strong>closePath ()</strong>. Этот метод пытается
                закрыть
                фигуру, рисуя прямую линию из&nbsp;текущей точки
                в&nbsp;начальную. Если фигура уже была закрыта или
                является просто точкой, то&nbsp;функция ничего
                не&nbsp;делает.</p>
              <blockquote>
                <p>При вызове <strong>fill ()</strong> каждая открытая
                  фигура закрывается автоматически, так что можно
                  не&nbsp;использовать <strong>closePath
                    ()</strong>. Но&nbsp;это
                  не&nbsp;работает в&nbsp;случае
                  вызова <strong>stroke ()</strong>.</p>
              </blockquote>
              <h3>Передвижение пера</h3>
              <p><strong>moveTo ()</strong>&nbsp;— полезная функция, которая
                ничего не&nbsp;рисует, но&nbsp;связана
                по&nbsp;смыслу с&nbsp;вышеописанными функциями.
                Её&nbsp;действие можно представить как отрыв (подъём)
                пера от&nbsp;бумаги и&nbsp;перемещение его в&nbsp;другое
                место:</p>
              <ul>
                <li><strong>moveTo (x, y)</strong> перемещает «перо»
                  в&nbsp;точку с&nbsp;координатами
                  <strong>x</strong>
                  и&nbsp;<strong>y</strong>.</li>
              </ul>
              <p>При инициализации <strong>canvas</strong> или при вызове
                <strong>beginPath ()</strong>, логично
                использовать функцию <strong>moveTo ()</strong> для
                перемещения в&nbsp;точку начала рисования. Можно
                использовать <strong>moveTo ()</strong> и&nbsp;для
                рисования несвязанного (незакрытого) контура.</p>
              <h2>Типы контуров</h2>
              <h3>Линии</h3>
              <p>Для рисования прямых линий используйте метод <strong>lineTo
                  ()</strong>:</p>
              <ul>
                <li><strong>lineTo (x, y)</strong> рисует линию
                  из&nbsp;текущей позиции до&nbsp;точки,
                  определённой
                  <strong>x</strong> и&nbsp;<strong>y</strong>.
                </li>
              </ul>
              <p>Этот метод принимает два аргумента <strong>x</strong>
                и&nbsp;<strong>y</strong>, они&nbsp;же — координаты
                конечной точки линии. Начальная точка зависит
                от&nbsp;ранее нарисованных путей, причём конечная точка
                предыдущего пути является начальной точкой следующего
                и&nbsp;т.&nbsp;д.</p>
              <p>Пример ниже рисует два треугольника: один закрашен сплошным
                цветом, другой обведён контуром:</p>
              <pre><code class="js language-js hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">draw</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'canvas'</span>);
  <span class="hljs-keyword">if</span> (canvas.getContext){
    <span class="hljs-keyword">let</span> ctx = canvas.getContext(<span class="hljs-string">'2d'</span>);

    <span class="hljs-comment">// треугольник с заливкой</span>
    ctx.beginPath();
    ctx.moveTo(<span class="hljs-number">25</span>,<span class="hljs-number">25</span>);
    ctx.lineTo(<span class="hljs-number">105</span>,<span class="hljs-number">25</span>);
    ctx.lineTo(<span class="hljs-number">25</span>,<span class="hljs-number">105</span>);
    ctx.fill();

    <span class="hljs-comment">// треугольник с обводкой</span>
    ctx.beginPath();
    ctx.moveTo(<span class="hljs-number">125</span>,<span class="hljs-number">125</span>);
    ctx.lineTo(<span class="hljs-number">125</span>,<span class="hljs-number">45</span>);
    ctx.lineTo(<span class="hljs-number">45</span>,<span class="hljs-number">125</span>);
    ctx.closePath();
    ctx.stroke();
  }
}
</code></pre>
              <p>Сперва вызовем <strong>beginPath ()</strong>, чтобы начать
                рисовать путь новой фигуры. Затем используем
                метод <strong>moveTo ()</strong>, чтобы переместить
                начальную точку в&nbsp;нужное положение. Ниже
                рисуются две линии, которые образуют две стороны
                треугольника, а&nbsp;функция <strong>closePath
                  ()</strong> или <strong>fill ()</strong>
                соединяет конечную и&nbsp;начальную точки, образуя
                треугольник.</p>
              <p><img src="images/triangles-canvas.png" alt="triangle"></p>
              <h3>Дуги</h3>
              <p>Для рисования дуг и&nbsp;окружностей используются методы
                <strong>arc ()</strong> и&nbsp;<strong>arcTo
                  ()</strong>:</p>
              <ul>
                <li><strong>arc (x, y, radius, startAngle, endAngle,
                    anticlockwise)</strong>&nbsp;— отрисовка
                  дуги
                  с&nbsp;центром в&nbsp;точке <strong>(x,
                    y)</strong> и&nbsp;радиусом
                  <strong>r</strong>, начиная
                  с&nbsp;угла <strong>startAngle</strong>
                  и&nbsp;заканчивая
                  в&nbsp;<strong>endAngle</strong>
                  в&nbsp;направлении против часовой стрелки
                  <strong>anticlockwise</strong>
                  (по&nbsp;умолчанию&nbsp;—
                  по&nbsp;ходу движения часовой стрелки);</li>
                <li><strong>arcTo (x1, y1, x2, y2,
                    radius)</strong>&nbsp;— отрисовка дуги
                  с&nbsp;заданными контрольными
                  точками и&nbsp;радиусом, с&nbsp;соединением этих
                  точек прямой линией.</li>
              </ul>
              <blockquote>
                <p>Углы в&nbsp;функции arc () измеряют в&nbsp;радианах,
                  а&nbsp;не&nbsp;в&nbsp;градусах. Для перевода
                  градусов в&nbsp;радианы можно использовать
                  JavaScript-выражение: <code>radians =
(Math.PI/180)*degrees</code>.</p>
              </blockquote>
              <h3>Кривые Безье</h3>
              <p>Следующий тип контуров&nbsp;— кривые Безье, доступные
                к&nbsp;тому&nbsp;же в&nbsp;кубическом
                и&nbsp;квадратичном вариантах. Обычно их&nbsp;используют
                при рисовании сложных составных фигур.</p>
              <ul>
                <li><strong>quadraticCurveTo (cp1x, cp1y, x,
                    y)</strong>&nbsp;— отрисовка
                  квадратичной кривой Безье
                  из&nbsp;текущей позиции «пера» в&nbsp;конечную
                  точку с&nbsp;координатами <strong>x</strong>
                  и&nbsp;<strong>y</strong>, координаты
                  единственной контрольной точки:
                  <strong>cp1x</strong>
                  и&nbsp;<strong>cp1y</strong>;</li>
                <li><strong>bezierCurveTo (cp1x, cp1y, cp2x, cp2y, x,
                    y)</strong>&nbsp;— отрисовка кубической
                  кривой
                  Безье из&nbsp;текущей позиции «пера»
                  в&nbsp;конечную точку с&nbsp;координатами
                  <strong>x</strong>
                  и&nbsp;<strong>y</strong> с&nbsp;использованием
                  двух контрольных точек с&nbsp;координатами
                  <strong>(cp1x, cp1y)</strong>
                  и&nbsp;<strong>(cp2x, cp2y)</strong>.</li>
              </ul>
              <p><img src="images/cb-canvas.png" alt="cubic-bezier-canvas">
              </p>
              <blockquote>
                <p>Чтобы задать начальную точку рисования кривой Безье
                  <strong>x0</strong>, <strong>y0</strong>
                  используйте функцию <strong>moveTo ()</strong>.
                </p>
              </blockquote>
              <h2>Создание комбинаций контуров и&nbsp;фигур</h2>
              <p>До&nbsp;сих пор в&nbsp;каждом примере использовался только
                один тип функции контуров для каждой фигуры.
                Однако нет никаких ограничений на&nbsp;количество или
                типы контуров, которые можно использовать для
                создания фигур. Давайте создадим набор известных игровых
                персонажей, комбинируя разные типы контуров:
              </p>
              <p><a href="files/Демо_Создание_комбинаций_контуров_и_фигур.zip">Демо</a></p>
              <h2>Рисование текста</h2>
              <p>Контекст рендеринга <strong>canvas</strong> предлагает два
                метода рисования текста:</p>
              <ul>
                <li><strong>fillText (text, x, y&nbsp;[,
                    maxWidth])</strong> вставляет заданный
                  текст в&nbsp;положении
                  <strong>(x, y)</strong>. Опционально можно
                  указать максимальную ширину;</li>
                <li><strong>strokeText (text, x, y&nbsp;[,
                    maxWidth])</strong> вставляет контур
                  заданного текста
                  в&nbsp;положении <strong>(x, y)</strong>.
                  Так&nbsp;же можно указать максимальную ширину,
                  опционально.</li>
              </ul>
              <pre><code class="js language-js hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">draw</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> ctx = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'canvas'</span>).getContext(<span class="hljs-string">'2d'</span>);
  ctx.font = <span class="hljs-string">"48px serif"</span>;
  ctx.fillText(<span class="hljs-string">"Hello world"</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>);
  ctx.strokeText(<span class="hljs-string">"Hello world"</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>);
}
</code></pre>
              <p><img src="images/text-canvas.png" alt="text-canvas"></p>
              <blockquote>
                <p>Кастомные шрифты нужно загрузить до&nbsp;начала
                  рисования, иначе пользователь сперва увидит
                  текст
                  со&nbsp;стандартным шрифтом, пока
                  не&nbsp;загрузится кастомный.</p>
              </blockquote>
              <h3>Измерение текста</h3>
              <p>Для измерения ширины текста без рисования его
                на&nbsp;<strong>canvas</strong> можно воспользоваться
                методом <strong>measureText ()</strong>.
                Он&nbsp;возвращает объект TextMetrics, сообщающий ширину
                текста
                (px), когда он&nbsp;будет нарисован
                на&nbsp;<strong>canvas</strong>:</p>
              <pre><code class="js language-js hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">draw</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> ctx = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'canvas'</span>).getContext(<span class="hljs-string">'2d'</span>);
  <span class="hljs-keyword">let</span> text = ctx.measureText(<span class="hljs-string">"foo"</span>); <span class="hljs-comment">// TextMetrics</span>
  text.width; <span class="hljs-comment">// 16;</span>
}
</code></pre>
              <h2>Рисование изображений</h2>
              <p>Импортирование изображений в&nbsp;<strong>canvas</strong>
                в&nbsp;основном состоит из&nbsp;двух этапов:
              </p>
              <ol>
                <li>
                  <p>Создать или взять существующий
                    в&nbsp;DOM-структуре объект
                    <strong>HTMLImageElement</strong>.
                    Также можно использовать изображение,
                    дав на&nbsp;него ссылку URL.</p>
                </li>
                <li>
                  <p>Добавить полученный объект-изображение
                    в&nbsp;контекст <strong>canvas</strong>.
                  </p>
                </li>
              </ol>
              <p>Для отрисовки изображения на&nbsp;<strong>canvas</strong>
                используют функцию <strong>drawImage
                  ()</strong></p>
              <ul>
                <li><strong>drawImage (image, x, y, width,
                    height)</strong> добавляет
                  на&nbsp;<strong>canvas</strong>
                  изображение <strong>image</strong>, его левый
                  верхний край находится в&nbsp;точке <strong>(x,
                    y)</strong>, ширина и&nbsp;высота
                  задаётся параметрами <strong>width</strong>
                  и&nbsp;<strong>height</strong> соответственно.
                </li>
              </ul>
              <p>Рассмотрим пример, в&nbsp;котором создадим объект-изображение
                с&nbsp;помощью конструктора <strong>Image
                  ()</strong>:</p>
              <pre><code class="js language-js hljs javascript"><span class="hljs-keyword">let</span> img = <span class="hljs-keyword">new</span> Image();   <span class="hljs-comment">// Создаёт новый элемент изображения</span>
img.src = <span class="hljs-string">'myImage.png'</span>; <span class="hljs-comment">// Устанавливает путь</span>
</code></pre>
              <p>Когда этот скрипт будет выполнен, изображение начнёт
                загружаться.</p>
              <p>Если попытаться вызвать функцию <strong>drawImage ()</strong>
                перед тем, как изображение загрузится,
                скрипт ничего не&nbsp;сделает (или может даже выдать
                исключение в&nbsp;старых браузерах). Поэтому
                необходимо использовать событие <strong>load</strong>,
                чтобы не&nbsp;пытаться сделать это прежде, чем
                изображение загрузится:</p>
              <pre><code class="js language-js hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">draw</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> ctx = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'canvas'</span>).getContext(<span class="hljs-string">'2d'</span>);
  ctx.drawImage(img, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
}

<span class="hljs-keyword">let</span> img = <span class="hljs-keyword">new</span> Image();   <span class="hljs-comment">// Создаёт новое изображение</span>
img.addEventListener(<span class="hljs-string">"load"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Здесь отрисовка изображения выполняет функцию</span>
  draw();
}, <span class="hljs-literal">false</span>);
img.src = <span class="hljs-string">'myImage.png'</span>; <span class="hljs-comment">// Устанавливает источник файла</span>
</code></pre>
              <h2>Очистка контекста</h2>
              <p>Для этого используют функцию <strong>clearRect ()</strong>.
              </p>
              <p><strong>clearRect (x, y, width, height)</strong>
                устанавливает прозрачный чёрный цвет для всех пикселей,
                расположенных внутри прямоугольника, заданного начальной
                точкой <strong>(x, y)</strong> и&nbsp;размерами
                <strong>(width, height)</strong>, таким образом стирая
                любое ранее нарисованное содержимое.</p>
              <div class="post-content__wrapper">
                <div class="card card--rating card--rating-embedded" data-rating="" data-rating-comment="">
                  <h3 class="card__header">Поделитесь, как вам
                    глава?</h3>
                  <div class="card__content">
                    <form class="card-rating " action="/animation/1/book/4.3/mark" method="POST">
                      <div class="card-rating__values">
                        <input class="sr-only" type="radio" name="value" id="book-rating-5" value="5"><label
                          for="book-rating-5"><span class="sr-only">Глава
                            —&nbsp;огонь!</span><svg aria-hidden="true" width="16" height="16">
                            <use xlink:href="img/sprites/up.svg?cs=fb70597153879c70ce140224310b7444b664990a#star">
                            </use>
                          </svg></label><input class="sr-only" type="radio" name="value" id="book-rating-4"
                          value="4"><label for="book-rating-4"><span class="sr-only">Это
                            было
                            полезно</span><svg aria-hidden="true" width="16" height="16">
                            <use xlink:href="img/sprites/up.svg?cs=fb70597153879c70ce140224310b7444b664990a#star">
                            </use>
                          </svg></label><input class="sr-only" type="radio" name="value" id="book-rating-3"
                          value="3"><label for="book-rating-3"><span class="sr-only">Неплохо,
                            но можно
                            лучше</span><svg aria-hidden="true" width="16" height="16">
                            <use xlink:href="img/sprites/up.svg?cs=fb70597153879c70ce140224310b7444b664990a#star">
                            </use>
                          </svg></label><input class="sr-only" type="radio" name="value" id="book-rating-2"
                          value="2"><label for="book-rating-2"><span class="sr-only">Ничего
                            полезного
                            не
                            было</span><svg aria-hidden="true" width="16" height="16">
                            <use xlink:href="img/sprites/up.svg?cs=fb70597153879c70ce140224310b7444b664990a#star">
                            </use>
                          </svg></label><input class="sr-only" type="radio" name="value" id="book-rating-1"
                          value="1"><label for="book-rating-1"><span class="sr-only">Я
                            напишу
                            эту
                            главу
                            лучше</span><svg aria-hidden="true" width="16" height="16">
                            <use xlink:href="img/sprites/up.svg?cs=fb70597153879c70ce140224310b7444b664990a#star">
                            </use>
                          </svg></label>
                      </div>
                      <p class="card-rating__title ">
                        Оцените главу</p>
                      <div class="card-rating__evaluate hidden ">
                        <span class="card-rating__text"></span>
                      </div>
                      <div class="card-rating__comment hidden">
                        <label class="sr-only" for="book-rating-comment">Комментарий</label>
                        <div class="form__group">
                          <textarea class="field field--area field--full-width" rows="2" cols="40"
                            placeholder="Оставьте ваш комментарий." name="comment" id="book-rating-comment"></textarea>
                          <p class="form__notice form__notice--red hidden">
                            Пожалуйста,
                            оставьте
                            комментарий.
                          </p>
                        </div><button class="button button--small" type="submit">Отправить</button>
                      </div>
                    </form>
                    <p class="alert alert--green alert--full-width text-right hidden" data-rating-finish=""
                      style="margin-top:10px;">
                      Спасибо!</p>
                  </div>
                </div><a class="button button--green" href="animation/1/book/4.3/complete">Продолжить</a>
              </div>
              <div class="card card--orphus">
                <div class="card__content">
                  <p><svg aria-hidden="true" width="16" height="16">
                      <use xlink:href="img/sprites/octicons.svg?cs=8e8ff00996768d7de5728299dcc0d03f923b069d#shield-16">
                      </use>
                    </svg> Если вы обнаружили ошибку или
                    неработающую ссылку, напишите об этом <a href="animation/1/curator"
                      data-intercom-link="">кураторам</a>.
                    <span class="nowrap">Мы
                      поправим.</span></p>
                </div>
              </div>
            </div>
          </div>
        </div>


      </div>
    </div>
  </div>
  <style id="intercom-lightweight-app-style" type="text/css">
    @keyframes intercom-lightweight-app-launcher {
      from {
        opacity: 0;
        transform: scale(0.5);
      }

      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    @keyframes intercom-lightweight-app-gradient {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    @keyframes intercom-lightweight-app-messenger {
      from {
        opacity: 0;
        transform: translateY(20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .intercom-lightweight-app {
      position: fixed;
      z-index: 2147483001;
      width: 0;
      height: 0;
      font-family: intercom-font, "Helvetica Neue", "Apple Color Emoji", Helvetica, Arial, sans-serif;

    }

    .intercom-lightweight-app-gradient {
      position: fixed;
      z-index: 2147483002;
      width: 500px;
      height: 500px;
      bottom: 0;
      right: 0;
      pointer-events: none;
      background: radial-gradient(ellipse at bottom right,
          rgba(29, 39, 54, 0.16) 0%,
          rgba(29, 39, 54, 0) 72%);
      animation: intercom-lightweight-app-gradient 200ms ease-out;
    }


    .intercom-lightweight-app-launcher {
      position: fixed;
      z-index: 2147483003;
      bottom: 20px;
      right: 20px;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: #2D2D44;
      cursor: pointer;
      box-shadow: 0 1px 6px 0 rgba(0, 0, 0, 0.06), 0 2px 32px 0 rgba(0, 0, 0, 0.16);
      animation: intercom-lightweight-app-launcher 250ms ease;
    }

    .intercom-lightweight-app-launcher:focus {
      outline: none;

    }


    .intercom-lightweight-app-launcher-icon {
      display: flex;
      align-items: center;
      justify-content: center;
      position: absolute;
      top: 0;
      left: 0;
      width: 60px;
      height: 60px;
      transition: transform 100ms linear, opacity 80ms linear;
    }

    .intercom-lightweight-app-launcher-icon-open {

      opacity: 1;
      transform: rotate(0deg) scale(1);

    }

    .intercom-lightweight-app-launcher-icon-open svg {
      width: 28px;
      height: 32px;
    }

    .intercom-lightweight-app-launcher-icon-open svg path {
      fill: rgb(255, 255, 255);
    }

    .intercom-lightweight-app-launcher-icon-self-serve {

      opacity: 1;
      transform: rotate(0deg) scale(1);

    }

    .intercom-lightweight-app-launcher-icon-self-serve svg {
      height: 56px;
    }

    .intercom-lightweight-app-launcher-icon-self-serve svg path {
      fill: rgb(255, 255, 255);
    }

    .intercom-lightweight-app-launcher-custom-icon-open {
      max-height: 36px;
      max-width: 36px;

      opacity: 1;
      transform: rotate(0deg) scale(1);

    }

    .intercom-lightweight-app-launcher-icon-minimize {

      opacity: 0;
      transform: rotate(-60deg) scale(0);

    }

    .intercom-lightweight-app-launcher-icon-minimize svg {
      width: 16px;
    }

    .intercom-lightweight-app-launcher-icon-minimize svg path {
      fill: rgb(255, 255, 255);
    }

    .intercom-lightweight-app-messenger {
      position: fixed;
      z-index: 2147483003;
      overflow: hidden;
      background-color: white;
      animation: intercom-lightweight-app-messenger 250ms ease-out;

      width: 376px;
      height: calc(100% - 40px);
      max-height: 704px;
      min-height: 250px;
      right: 20px;
      bottom: 20px;
      box-shadow: 0 5px 40px rgba(0, 0, 0, 0.16);
      border-radius: 8px;

    }

    .intercom-lightweight-app-messenger-header {
      height: 75px;
      background: linear-gradient(135deg,
          rgb(45, 45, 68) 0%,
          rgb(4, 4, 7) 100%);
    }

    @media print {
      .intercom-lightweight-app {
        display: none;
      }
    }
  </style>
  </div>
  <div id="naptha_container0932014_0707"></div>
</body>

</html>